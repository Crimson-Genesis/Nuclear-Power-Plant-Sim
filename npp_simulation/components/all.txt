./turbine_generator/turbine.py:import os
./turbine_generator/turbine.py:import sys
./turbine_generator/turbine.py:
./turbine_generator/turbine.py:from prompt_toolkit.buffer import reshape_text
./turbine_generator/turbine.py:sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
./turbine_generator/turbine.py:from lib.lib import *
./turbine_generator/turbine.py:
./turbine_generator/turbine.py:import time, json, threading, random
./turbine_generator/turbine.py:import zmq
./turbine_generator/turbine.py:import yaml
./turbine_generator/turbine.py:
./turbine_generator/turbine.py:class Turbine:
./turbine_generator/turbine.py:    def __init__(self,):
./turbine_generator/turbine.py:        with open(config_file_name(), "r") as file:
./turbine_generator/turbine.py:            self.config = yaml.safe_load(file)
./turbine_generator/turbine.py:
./turbine_generator/turbine.py:        # pprint(self.config)
./turbine_generator/turbine.py:        self.ctx = zmq.Context()
./turbine_generator/turbine.py:        self.ctrl_endpoint = self.config["connections"]["ctrl"]["endpoint"]
./turbine_generator/turbine.py:        self.tick_endpoint = self.config["connections"]["tick"]["endpoint"]
./turbine_generator/turbine.py:        self.heartbeat_endpoint = self.config["connections"]["heartbeat"]["endpoint"]
./turbine_generator/turbine.py:        self.telemetry_endpoint = self.config["connections"]["telemetry"]["endpoint"]
./turbine_generator/turbine.py:
./turbine_generator/turbine.py:        self.ctrl = self.ctx.socket(
./turbine_generator/turbine.py:            getattr(zmq, self.config["connections"]["ctrl"]["type"])
./turbine_generator/turbine.py:        )
./turbine_generator/turbine.py:        # self.ctrl.connect(self.ctrl_endpoint)
./turbine_generator/turbine.py:        self.name = get_name()
./turbine_generator/turbine.py:        self.ctrl.setsockopt_string(zmq.IDENTITY, self.name)
./turbine_generator/turbine.py:        get_connection_object(self.ctrl, self.config["connections"]["ctrl"]["type"])(self.ctrl_endpoint)
./turbine_generator/turbine.py:
./turbine_generator/turbine.py:        self.tick = self.ctx.socket(
./turbine_generator/turbine.py:            getattr(zmq, self.config["connections"]["tick"]["type"])
./turbine_generator/turbine.py:        )
./turbine_generator/turbine.py:        self.tick.setsockopt_string(zmq.SUBSCRIBE, "")
./turbine_generator/turbine.py:
./turbine_generator/turbine.py:        self.heartbeat = self.ctx.socket(
./turbine_generator/turbine.py:            getattr(zmq, self.config["connections"]["heartbeat"]["type"])
./turbine_generator/turbine.py:        )
./turbine_generator/turbine.py:        self.telemetry = self.ctx.socket(
./turbine_generator/turbine.py:            getattr(zmq, self.config["connections"]["telemetry"]["type"])
./turbine_generator/turbine.py:        )
./turbine_generator/turbine.py:        self.running = False
./turbine_generator/turbine.py:
./turbine_generator/turbine.py:    def establish_connections(self):
./turbine_generator/turbine.py:        self.running = True
./turbine_generator/turbine.py:        get_connection_object(self.tick, self.config["connections"]["tick"]["type"])(self.tick_endpoint)
./turbine_generator/turbine.py:        get_connection_object(self.telemetry, self.config["connections"]["telemetry"]["type"])(self.telemetry_endpoint)
./turbine_generator/turbine.py:        get_connection_object(self.heartbeat, self.config["connections"]["heartbeat"]["type"])(self.heartbeat_endpoint)
./turbine_generator/turbine.py:        self.tick_thread.start()
./turbine_generator/turbine.py:        return "Tick, Telemetry and HeartBeat"
./turbine_generator/turbine.py:
./turbine_generator/turbine.py:    def start(self):
./turbine_generator/turbine.py:        self.control_thread = threading.Thread(target=self._control_loop, daemon=True)
./turbine_generator/turbine.py:        self.control_thread.start()
./turbine_generator/turbine.py:        self.dealerListen_thread = threading.Thread(target=self._dealerListener, daemon=True)
./turbine_generator/turbine.py:        self.dealerListen_thread.start()
./turbine_generator/turbine.py:        self.tick_thread = threading.Thread(target=self._tick_loop, daemon=True)
./turbine_generator/turbine.py:        while True:
./turbine_generator/turbine.py:            time.sleep(1)
./turbine_generator/turbine.py:
./turbine_generator/turbine.py:    def _tick_loop(self):
./turbine_generator/turbine.py:        while self.running:
./turbine_generator/turbine.py:            try:
./turbine_generator/turbine.py:                data = self.tick.recv_json(flags=zmq.NOBLOCK)
./turbine_generator/turbine.py:                # self.send_msg(data, type_="tick-check")
./turbine_generator/turbine.py:                # real_sleep = self.time_step / max(self.time_scale, 1e-9)
./turbine_generator/turbine.py:                time.sleep(1)
./turbine_generator/turbine.py:            except zmq.Again:
./turbine_generator/turbine.py:                time.sleep(0.05)  # poll for control commands while paused
./turbine_generator/turbine.py:
./turbine_generator/turbine.py:    def _control_loop(self):
./turbine_generator/turbine.py:        self.send_msg("Okey", type_="check", data=random.randint(1, 1000))
./turbine_generator/turbine.py:        self.running = True
./turbine_generator/turbine.py:        while self.running:
./turbine_generator/turbine.py:            time.sleep(2)
./turbine_generator/turbine.py:
./turbine_generator/turbine.py:    def _heartbeat_loop(self):
./turbine_generator/turbine.py:        ...
./turbine_generator/turbine.py:    def _dealerListener(self):
./turbine_generator/turbine.py:        while True:
./turbine_generator/turbine.py:            try:
./turbine_generator/turbine.py:                identity, msg = self.ctrl.recv_multipart(flags=zmq.NOBLOCK)
./turbine_generator/turbine.py:                if identity or msg:
./turbine_generator/turbine.py:                    decoded_msg = json.loads(msg.decode())
./turbine_generator/turbine.py:                    if (
./turbine_generator/turbine.py:                        decoded_msg["type"] == "command"
./turbine_generator/turbine.py:                        and decoded_msg["name"] == "control_system"
./turbine_generator/turbine.py:                    ):
./turbine_generator/turbine.py:                        self._executation(decoded_msg)
./turbine_generator/turbine.py:            except zmq.Again:
./turbine_generator/turbine.py:                pass
./turbine_generator/turbine.py:            time.sleep(0.05)
./turbine_generator/turbine.py:
./turbine_generator/turbine.py:    def _executation(self, msg):
./turbine_generator/turbine.py:        cmd = msg["command"]
./turbine_generator/turbine.py:        if cmd in ("establish_connections"):
./turbine_generator/turbine.py:            cc = self.establish_connections()
./turbine_generator/turbine.py:            self.send_msg(
./turbine_generator/turbine.py:                f"Establish-ED Connections of {cc} at {self.name}", type_="status"
./turbine_generator/turbine.py:            )
./turbine_generator/turbine.py:        else:
./turbine_generator/turbine.py:            self.send_msg("Error", ok=False, error="unknown command")
./turbine_generator/turbine.py:
./turbine_generator/turbine.py:    def send_msg(self, msg, type_="status", **kwargs):
./turbine_generator/turbine.py:        data = {
./turbine_generator/turbine.py:            "type": type_,
./turbine_generator/turbine.py:            "name": self.name,
./turbine_generator/turbine.py:            "status": f"{'Running' if self.running else 'Not Running'}",
./turbine_generator/turbine.py:            "msg": msg,
./turbine_generator/turbine.py:            **kwargs,
./turbine_generator/turbine.py:        }
./turbine_generator/turbine.py:        self.ctrl.send_multipart([b"", json.dumps(data).encode()])
./turbine_generator/turbine.py:
./turbine_generator/turbine.py:
./turbine_generator/turbine.py:if __name__ == "__main__":
./turbine_generator/turbine.py:    try:
./turbine_generator/turbine.py:        turbine = Turbine()
./turbine_generator/turbine.py:        turbine.start()
./turbine_generator/turbine.py:    except KeyboardInterrupt:
./turbine_generator/turbine.py:        print("Keyboard Interrupt !!!")
./turbine_generator/turbine.py:    except EOFError:
./turbine_generator/turbine.py:        print("EOF Error !!!")
./turbine_generator/turbine.py:
./turbine_generator/turbine.py:
./steam_generator/steam_generator.py:import os
./steam_generator/steam_generator.py:import sys
./steam_generator/steam_generator.py:sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
./steam_generator/steam_generator.py:from lib.lib import *
./steam_generator/steam_generator.py:
./steam_generator/steam_generator.py:import time, json, threading, random
./steam_generator/steam_generator.py:import zmq
./steam_generator/steam_generator.py:import yaml
./steam_generator/steam_generator.py:
./steam_generator/steam_generator.py:class SteamGenerator:
./steam_generator/steam_generator.py:    def __init__(self,):
./steam_generator/steam_generator.py:        with open(config_file_name(), "r") as file:
./steam_generator/steam_generator.py:            self.config = yaml.safe_load(file)
./steam_generator/steam_generator.py:
./steam_generator/steam_generator.py:        # pprint(self.config)
./steam_generator/steam_generator.py:        self.ctx = zmq.Context()
./steam_generator/steam_generator.py:        self.ctrl_endpoint = self.config["connections"]["ctrl"]["endpoint"]
./steam_generator/steam_generator.py:        self.tick_endpoint = self.config["connections"]["tick"]["endpoint"]
./steam_generator/steam_generator.py:        self.heartbeat_endpoint = self.config["connections"]["heartbeat"]["endpoint"]
./steam_generator/steam_generator.py:        self.telemetry_endpoint = self.config["connections"]["telemetry"]["endpoint"]
./steam_generator/steam_generator.py:
./steam_generator/steam_generator.py:        self.ctrl = self.ctx.socket(
./steam_generator/steam_generator.py:            getattr(zmq, self.config["connections"]["ctrl"]["type"])
./steam_generator/steam_generator.py:        )
./steam_generator/steam_generator.py:        # self.ctrl.connect(self.ctrl_endpoint)
./steam_generator/steam_generator.py:        self.name = get_name()
./steam_generator/steam_generator.py:        self.ctrl.setsockopt_string(zmq.IDENTITY, self.name)
./steam_generator/steam_generator.py:        get_connection_object(self.ctrl, self.config["connections"]["ctrl"]["type"])(self.ctrl_endpoint)
./steam_generator/steam_generator.py:
./steam_generator/steam_generator.py:        self.tick = self.ctx.socket(
./steam_generator/steam_generator.py:            getattr(zmq, self.config["connections"]["tick"]["type"])
./steam_generator/steam_generator.py:        )
./steam_generator/steam_generator.py:        self.tick.setsockopt_string(zmq.SUBSCRIBE, "")
./steam_generator/steam_generator.py:
./steam_generator/steam_generator.py:        self.heartbeat = self.ctx.socket(
./steam_generator/steam_generator.py:            getattr(zmq, self.config["connections"]["heartbeat"]["type"])
./steam_generator/steam_generator.py:        )
./steam_generator/steam_generator.py:        self.telemetry = self.ctx.socket(
./steam_generator/steam_generator.py:            getattr(zmq, self.config["connections"]["telemetry"]["type"])
./steam_generator/steam_generator.py:        )
./steam_generator/steam_generator.py:        self.running = False
./steam_generator/steam_generator.py:
./steam_generator/steam_generator.py:    def establish_connections(self):
./steam_generator/steam_generator.py:        self.running = True
./steam_generator/steam_generator.py:        get_connection_object(self.tick, self.config["connections"]["tick"]["type"])(self.tick_endpoint)
./steam_generator/steam_generator.py:        get_connection_object(self.telemetry, self.config["connections"]["telemetry"]["type"])(self.telemetry_endpoint)
./steam_generator/steam_generator.py:        get_connection_object(self.heartbeat, self.config["connections"]["heartbeat"]["type"])(self.heartbeat_endpoint)
./steam_generator/steam_generator.py:        self.tick_thread.start()
./steam_generator/steam_generator.py:        return "Tick, Telemetry and HeartBeat"
./steam_generator/steam_generator.py:
./steam_generator/steam_generator.py:    def start(self):
./steam_generator/steam_generator.py:        self.control_thread = threading.Thread(target=self._control_loop, daemon=True)
./steam_generator/steam_generator.py:        self.control_thread.start()
./steam_generator/steam_generator.py:        self.dealerListen_thread = threading.Thread(target=self._dealerListener, daemon=True)
./steam_generator/steam_generator.py:        self.dealerListen_thread.start()
./steam_generator/steam_generator.py:
./steam_generator/steam_generator.py:        self.tick_thread = threading.Thread(target=self._tick_loop, daemon=True)
./steam_generator/steam_generator.py:        while True:
./steam_generator/steam_generator.py:            time.sleep(1)
./steam_generator/steam_generator.py:
./steam_generator/steam_generator.py:    def _tick_loop(self):
./steam_generator/steam_generator.py:        while self.running:
./steam_generator/steam_generator.py:            try:
./steam_generator/steam_generator.py:                data = self.tick.recv_json(flags=zmq.NOBLOCK)
./steam_generator/steam_generator.py:                # self.send_msg(data, type_="tick-check")
./steam_generator/steam_generator.py:                # real_sleep = self.time_step / max(self.time_scale, 1e-9)
./steam_generator/steam_generator.py:                time.sleep(1)
./steam_generator/steam_generator.py:            except zmq.Again:
./steam_generator/steam_generator.py:                time.sleep(0.05)  # poll for control commands while paused
./steam_generator/steam_generator.py:
./steam_generator/steam_generator.py:    def _control_loop(self):
./steam_generator/steam_generator.py:        self.send_msg("Okey", type_="check", data=random.randint(1, 1000))
./steam_generator/steam_generator.py:        self.running = True
./steam_generator/steam_generator.py:        while self.running:
./steam_generator/steam_generator.py:            time.sleep(2)
./steam_generator/steam_generator.py:
./steam_generator/steam_generator.py:    def _heartbeat_loop(self):
./steam_generator/steam_generator.py:        ...
./steam_generator/steam_generator.py:
./steam_generator/steam_generator.py:    def _dealerListener(self):
./steam_generator/steam_generator.py:        while True:
./steam_generator/steam_generator.py:            try:
./steam_generator/steam_generator.py:                identity, msg = self.ctrl.recv_multipart(flags=zmq.NOBLOCK)
./steam_generator/steam_generator.py:                if identity or msg:
./steam_generator/steam_generator.py:                    decoded_msg = json.loads(msg.decode())
./steam_generator/steam_generator.py:                    if (
./steam_generator/steam_generator.py:                        decoded_msg["type"] == "command"
./steam_generator/steam_generator.py:                        and decoded_msg["name"] == "control_system"
./steam_generator/steam_generator.py:                    ):
./steam_generator/steam_generator.py:                        self._executation(decoded_msg)
./steam_generator/steam_generator.py:            except zmq.Again:
./steam_generator/steam_generator.py:                pass
./steam_generator/steam_generator.py:            time.sleep(0.05)
./steam_generator/steam_generator.py:
./steam_generator/steam_generator.py:    def _executation(self, msg):
./steam_generator/steam_generator.py:        cmd = msg["command"]
./steam_generator/steam_generator.py:        if cmd == "establish_connections":
./steam_generator/steam_generator.py:            cc = self.establish_connections()
./steam_generator/steam_generator.py:            self.send_msg(
./steam_generator/steam_generator.py:                f"Establish-ED Connections of {cc} at {self.name}", type_="status"
./steam_generator/steam_generator.py:            )
./steam_generator/steam_generator.py:
./steam_generator/steam_generator.py:        else:
./steam_generator/steam_generator.py:            self.send_msg("Error", ok=False, error="unknown command")
./steam_generator/steam_generator.py:
./steam_generator/steam_generator.py:    def send_msg(self, msg, type_="status", **kwargs):
./steam_generator/steam_generator.py:        data = {
./steam_generator/steam_generator.py:            "type": type_,
./steam_generator/steam_generator.py:            "name": self.name,
./steam_generator/steam_generator.py:            "status": f"{'Running' if self.running else 'Not Running'}",
./steam_generator/steam_generator.py:            "msg": msg,
./steam_generator/steam_generator.py:            **kwargs,
./steam_generator/steam_generator.py:        }
./steam_generator/steam_generator.py:        self.ctrl.send_multipart([b"", json.dumps(data).encode()])
./steam_generator/steam_generator.py:
./steam_generator/steam_generator.py:
./steam_generator/steam_generator.py:if __name__ == "__main__":
./steam_generator/steam_generator.py:    try:
./steam_generator/steam_generator.py:        sg1 = SteamGenerator()
./steam_generator/steam_generator.py:        sg1.start()
./steam_generator/steam_generator.py:    except KeyboardInterrupt:
./steam_generator/steam_generator.py:        print("Keyboard Interrupt !!!")
./steam_generator/steam_generator.py:    except EOFError:
./steam_generator/steam_generator.py:        print("EOF Error !!!")
./grid_interface/grid.py:import os
./grid_interface/grid.py:import sys
./grid_interface/grid.py:sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
./grid_interface/grid.py:from lib.lib import *
./grid_interface/grid.py:
./grid_interface/grid.py:import time, json, threading, random
./grid_interface/grid.py:import zmq
./grid_interface/grid.py:import yaml
./grid_interface/grid.py:
./grid_interface/grid.py:class Grid:
./grid_interface/grid.py:    def __init__(self,):
./grid_interface/grid.py:        with open(config_file_name(), "r") as file:
./grid_interface/grid.py:            self.config = yaml.safe_load(file)
./grid_interface/grid.py:
./grid_interface/grid.py:        # pprint(self.config)
./grid_interface/grid.py:        self.ctx = zmq.Context()
./grid_interface/grid.py:        self.ctrl_endpoint = self.config["connections"]["ctrl"]["endpoint"]
./grid_interface/grid.py:        self.tick_endpoint = self.config["connections"]["tick"]["endpoint"]
./grid_interface/grid.py:        self.heartbeat_endpoint = self.config["connections"]["heartbeat"]["endpoint"]
./grid_interface/grid.py:        self.telemetry_endpoint = self.config["connections"]["telemetry"]["endpoint"]
./grid_interface/grid.py:
./grid_interface/grid.py:        self.ctrl = self.ctx.socket(
./grid_interface/grid.py:            getattr(zmq, self.config["connections"]["ctrl"]["type"])
./grid_interface/grid.py:        )
./grid_interface/grid.py:        self.name = get_name()
./grid_interface/grid.py:        self.ctrl.setsockopt_string(zmq.IDENTITY, self.name)
./grid_interface/grid.py:
./grid_interface/grid.py:        # self.ctrl.connect(self.ctrl_endpoint)
./grid_interface/grid.py:        get_connection_object(self.ctrl, self.config["connections"]["ctrl"]["type"])(self.ctrl_endpoint)
./grid_interface/grid.py:
./grid_interface/grid.py:        self.tick = self.ctx.socket(
./grid_interface/grid.py:            getattr(zmq, self.config["connections"]["tick"]["type"])
./grid_interface/grid.py:        )
./grid_interface/grid.py:        self.tick.setsockopt_string(zmq.SUBSCRIBE, "")
./grid_interface/grid.py:
./grid_interface/grid.py:        self.heartbeat = self.ctx.socket(
./grid_interface/grid.py:            getattr(zmq, self.config["connections"]["heartbeat"]["type"])
./grid_interface/grid.py:        )
./grid_interface/grid.py:        self.telemetry = self.ctx.socket(
./grid_interface/grid.py:            getattr(zmq, self.config["connections"]["telemetry"]["type"])
./grid_interface/grid.py:        )
./grid_interface/grid.py:        self.running = False
./grid_interface/grid.py:
./grid_interface/grid.py:    def establish_connections(self):
./grid_interface/grid.py:        self.running = True
./grid_interface/grid.py:        get_connection_object(self.tick, self.config["connections"]["tick"]["type"])(self.tick_endpoint)
./grid_interface/grid.py:        get_connection_object(self.telemetry, self.config["connections"]["telemetry"]["type"])(self.telemetry_endpoint)
./grid_interface/grid.py:        get_connection_object(self.heartbeat, self.config["connections"]["heartbeat"]["type"])(self.heartbeat_endpoint)
./grid_interface/grid.py:        self.tick_thread.start()
./grid_interface/grid.py:        return "Tick, Telemetry and HeartBeat"
./grid_interface/grid.py:
./grid_interface/grid.py:    def start(self):
./grid_interface/grid.py:        self.control_thread = threading.Thread(target=self._control_loop, daemon=True)
./grid_interface/grid.py:        self.control_thread.start()
./grid_interface/grid.py:        self.dealerListen_thread = threading.Thread(target=self._dealerListener, daemon=True)
./grid_interface/grid.py:        self.dealerListen_thread.start()
./grid_interface/grid.py:        self.tick_thread = threading.Thread(target=self._tick_loop, daemon=True)
./grid_interface/grid.py:        while True:
./grid_interface/grid.py:            time.sleep(1)
./grid_interface/grid.py:
./grid_interface/grid.py:    def _tick_loop(self):
./grid_interface/grid.py:        while self.running:
./grid_interface/grid.py:            try:
./grid_interface/grid.py:                data = self.tick.recv_json(flags=zmq.NOBLOCK)
./grid_interface/grid.py:                # self.send_msg(data, type_="tick-check")
./grid_interface/grid.py:                # real_sleep = self.time_step / max(self.time_scale, 1e-9)
./grid_interface/grid.py:                time.sleep(1)
./grid_interface/grid.py:            except zmq.Again:
./grid_interface/grid.py:                time.sleep(0.05)  # poll for control commands while paused
./grid_interface/grid.py:
./grid_interface/grid.py:    def _control_loop(self):
./grid_interface/grid.py:        self.send_msg("Okey", type_="check", data=random.randint(1, 1000))
./grid_interface/grid.py:        self.running = True
./grid_interface/grid.py:        while self.running:
./grid_interface/grid.py:            time.sleep(2)
./grid_interface/grid.py:
./grid_interface/grid.py:    def _heartbeat_loop(self):
./grid_interface/grid.py:        ...
./grid_interface/grid.py:
./grid_interface/grid.py:    def _dealerListener(self):
./grid_interface/grid.py:        while True:
./grid_interface/grid.py:            try:
./grid_interface/grid.py:                identity, msg = self.ctrl.recv_multipart(flags=zmq.NOBLOCK)
./grid_interface/grid.py:                if identity or msg:
./grid_interface/grid.py:                    decoded_msg = json.loads(msg.decode())
./grid_interface/grid.py:                    if (
./grid_interface/grid.py:                        decoded_msg["type"] == "command"
./grid_interface/grid.py:                        and decoded_msg["name"] == "control_system"
./grid_interface/grid.py:                    ):
./grid_interface/grid.py:                        self._executation(decoded_msg)
./grid_interface/grid.py:            except zmq.Again:
./grid_interface/grid.py:                pass
./grid_interface/grid.py:            time.sleep(0.05)
./grid_interface/grid.py:
./grid_interface/grid.py:    def _executation(self, msg):
./grid_interface/grid.py:        cmd = msg["command"]
./grid_interface/grid.py:        if cmd == "establish_connections":
./grid_interface/grid.py:            cc = self.establish_connections()
./grid_interface/grid.py:            self.send_msg(
./grid_interface/grid.py:                f"Establish-ED Connections of {cc} at {self.name}", type_="status"
./grid_interface/grid.py:            )
./grid_interface/grid.py:        else:
./grid_interface/grid.py:            self.send_msg("Error", ok=False, error="unknown command")
./grid_interface/grid.py:
./grid_interface/grid.py:    def send_msg(self, msg, type_="status", **kwargs):
./grid_interface/grid.py:        data = {
./grid_interface/grid.py:            "type": type_,
./grid_interface/grid.py:            "name": self.name,
./grid_interface/grid.py:            "status": f"{'Running' if self.running else 'Not Running'}",
./grid_interface/grid.py:            "msg": msg,
./grid_interface/grid.py:            **kwargs,
./grid_interface/grid.py:        }
./grid_interface/grid.py:        self.ctrl.send_multipart([b"", json.dumps(data).encode()])
./grid_interface/grid.py:
./grid_interface/grid.py:
./grid_interface/grid.py:if __name__ == "__main__":
./grid_interface/grid.py:    try:
./grid_interface/grid.py:        grid = Grid()
./grid_interface/grid.py:        grid.start()
./grid_interface/grid.py:    except KeyboardInterrupt:
./grid_interface/grid.py:        print("Keyboard Interrupt !!!")
./grid_interface/grid.py:    except EOFError:
./grid_interface/grid.py:        print("EOF Error !!!")
./grid_interface/grid.py:
./grid_interface/grid.py:
./grid_interface/grid.py:
./reactor_core/reactor.py:import pickle
./reactor_core/reactor.py:import time, json, threading
./reactor_core/reactor.py:import zmq
./reactor_core/reactor.py:import os
./reactor_core/reactor.py:import sys
./reactor_core/reactor.py:import random
./reactor_core/reactor.py:
./reactor_core/reactor.py:import glob
./reactor_core/reactor.py:from datetime import datetime
./reactor_core/reactor.py:import openmc
./reactor_core/reactor.py:
./reactor_core/reactor.py:sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
./reactor_core/reactor.py:
./reactor_core/reactor.py:from lib.lib import *
./reactor_core/reactor.py:
./reactor_core/reactor.py:import yaml
./reactor_core/reactor.py:
./reactor_core/reactor.py:# ----------------- Add these methods to your ParticalSim class -----------------
./reactor_core/reactor.py:
./reactor_core/reactor.py:import csv
./reactor_core/reactor.py:import numpy as np
./reactor_core/reactor.py:import shutil
./reactor_core/reactor.py:import tempfile
./reactor_core/reactor.py:from copy import deepcopy
./reactor_core/reactor.py:from pathlib import Path
./reactor_core/reactor.py:import json
./reactor_core/reactor.py:
./reactor_core/reactor.py:# Place inside your ParticalSim class definition
./reactor_core/reactor.py:
./reactor_core/reactor.py:
./reactor_core/reactor.py:class ParticalSim:
./reactor_core/reactor.py:    def __init__(
./reactor_core/reactor.py:        self,
./reactor_core/reactor.py:    ):
./reactor_core/reactor.py:        # ---------------- USER TUNABLES ----------------
./reactor_core/reactor.py:        self.OUTER_RADIUS = 50.0  # cm, outer bounding sphere
./reactor_core/reactor.py:        self.FUEL_RADIUS = 0.39  # cm, fuel cylinder radius
./reactor_core/reactor.py:        self.DEBUG = (
./reactor_core/reactor.py:            True  # if True create geometry plots and use small runs for quick debugging
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:        self.RUN_DEPLETION = (
./reactor_core/reactor.py:            False  # set True only if openmc.deplete is configured & you want depletion
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:        # Debug run sizes (fast)
./reactor_core/reactor.py:        self.BATCHES = 20
./reactor_core/reactor.py:        statefile = self.latest_statepoint()
./reactor_core/reactor.py:        if statefile[0]:
./reactor_core/reactor.py:            self.BATCHES = statefile[1]
./reactor_core/reactor.py:        self.INACTIVE = 5
./reactor_core/reactor.py:        self.PARTICLES = 20000
./reactor_core/reactor.py:        self.SEED = 12345
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # Mesh tally settings
./reactor_core/reactor.py:        self.NX, self.NY, self.NZ = 20, 20, 20
./reactor_core/reactor.py:        self.MESH_MARGIN = 0.1  # avoid placing mesh exactly on boundary
./reactor_core/reactor.py:        # ------------------------------------------------
./reactor_core/reactor.py:
./reactor_core/reactor.py:        self.data_dict = dict()
./reactor_core/reactor.py:        self.data_dict["batch_size"] = self.BATCHES
./reactor_core/reactor.py:    def updateBatchSize(self, num):
./reactor_core/reactor.py:        self.BATCHES += num
./reactor_core/reactor.py:        self.data_dict["batch_size"] = self.BATCHES
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def build_materials(self):
./reactor_core/reactor.py:        # simple demo composition (atomic fractions). Replace with number densities for production.
./reactor_core/reactor.py:        fuel = openmc.Material(name="UO2 fuel")
./reactor_core/reactor.py:        fuel.add_nuclide("U235", 0.04)
./reactor_core/reactor.py:        fuel.add_nuclide("U238", 0.96)
./reactor_core/reactor.py:        fuel.add_nuclide("O16", 2.0)
./reactor_core/reactor.py:        fuel.set_density("g/cm3", 10.5)
./reactor_core/reactor.py:
./reactor_core/reactor.py:        water = openmc.Material(name="Light water")
./reactor_core/reactor.py:        water.add_element("H", 2.0)
./reactor_core/reactor.py:        water.add_element("O", 1.0)
./reactor_core/reactor.py:        water.set_density("g/cm3", 0.743)
./reactor_core/reactor.py:        # s(alpha,beta) if available
./reactor_core/reactor.py:        try:
./reactor_core/reactor.py:            water.add_s_alpha_beta("c_H_in_H2O")
./reactor_core/reactor.py:        except Exception:
./reactor_core/reactor.py:            # missing S(a,b) data is fine — script will warn
./reactor_core/reactor.py:            pass
./reactor_core/reactor.py:
./reactor_core/reactor.py:        mats = openmc.Materials([fuel, water])
./reactor_core/reactor.py:        mats.export_to_xml()
./reactor_core/reactor.py:        return fuel, water, mats
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def build_geometry(self, fuel, water):
./reactor_core/reactor.py:        # Surfaces
./reactor_core/reactor.py:        fuel_cyl = openmc.ZCylinder(r=self.FUEL_RADIUS)
./reactor_core/reactor.py:        outer_sphere = openmc.Sphere(r=self.OUTER_RADIUS, boundary_type="vacuum")
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # Cells — IMPORTANT: bind both fuel & moderator inside outer_sphere to avoid lost particles
./reactor_core/reactor.py:        fuel_cell = openmc.Cell(name="fuel")
./reactor_core/reactor.py:        fuel_cell.fill = fuel
./reactor_core/reactor.py:        fuel_cell.region = (
./reactor_core/reactor.py:            -fuel_cyl & -outer_sphere
./reactor_core/reactor.py:        )  # <-- fixed: bounded by outer sphere
./reactor_core/reactor.py:
./reactor_core/reactor.py:        moderator_cell = openmc.Cell(name="moderator")
./reactor_core/reactor.py:        moderator_cell.fill = water
./reactor_core/reactor.py:        moderator_cell.region = +fuel_cyl & -outer_sphere
./reactor_core/reactor.py:
./reactor_core/reactor.py:        root_universe = openmc.Universe(cells=[fuel_cell, moderator_cell])
./reactor_core/reactor.py:        geom = openmc.Geometry(root_universe)
./reactor_core/reactor.py:        geom.export_to_xml()
./reactor_core/reactor.py:        return geom, fuel_cell, moderator_cell, fuel_cyl, outer_sphere
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def build_settings(self):
./reactor_core/reactor.py:        settings = openmc.Settings()
./reactor_core/reactor.py:        settings.run_mode = "eigenvalue"
./reactor_core/reactor.py:        settings.batches = self.BATCHES
./reactor_core/reactor.py:        settings.inactive = self.INACTIVE
./reactor_core/reactor.py:        settings.particles = self.PARTICLES
./reactor_core/reactor.py:        settings.seed = self.SEED
./reactor_core/reactor.py:        settings.photon_transport = True
./reactor_core/reactor.py:        # overlap check and helpful temperature interpolation if ACE supports it
./reactor_core/reactor.py:        settings.check_overlaps = True
./reactor_core/reactor.py:        settings.temperature = {"method": "interpolation"}
./reactor_core/reactor.py:        settings.export_to_xml()
./reactor_core/reactor.py:        return settings
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def build_tallies(self, fuel_cell, outer_sphere):
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        Build a comprehensive set of tallies for an NPP-level simulation.
./reactor_core/reactor.py:        This attempts many commonly useful scores; invalid/unavailable scores are skipped
./reactor_core/reactor.py:        with a warning (so the script remains robust across OpenMC versions).
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        tallies = openmc.Tallies()
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # def add_tally_safe(name, filters=None, scores=None, nuclides=None):
./reactor_core/reactor.py:        #     """
./reactor_core/reactor.py:        #     Helper: create tally and append to tallies. If OpenMC rejects the scores,
./reactor_core/reactor.py:        #     catch the exception, print a warning, and skip.
./reactor_core/reactor.py:        #     """
./reactor_core/reactor.py:        #     try:
./reactor_core/reactor.py:        #         t = openmc.Tally(name=name)
./reactor_core/reactor.py:        #         if filters:
./reactor_core/reactor.py:        #             t.filters = filters
./reactor_core/reactor.py:        #         if nuclides:
./reactor_core/reactor.py:        #             t.nuclides = nuclides
./reactor_core/reactor.py:        #         if scores:
./reactor_core/reactor.py:        #             t.scores = scores
./reactor_core/reactor.py:        #         tallies.append(t)
./reactor_core/reactor.py:        #         return t
./reactor_core/reactor.py:        #     except Exception as e:
./reactor_core/reactor.py:        #         print(f"[WARN] Could not create tally '{name}' with scores {scores}: {e}")
./reactor_core/reactor.py:        #         return None
./reactor_core/reactor.py:
./reactor_core/reactor.py:        def add_tally_safe(name, filters=None, scores=None, nuclides=None):
./reactor_core/reactor.py:            """
./reactor_core/reactor.py:            Create tally while normalizing/deduplicating scores.
./reactor_core/reactor.py:            Will skip the tally if OpenMC rejects it or if no valid scores remain.
./reactor_core/reactor.py:            """
./reactor_core/reactor.py:            # Normalize score strings (strip, lower) and deduplicate preserving order
./reactor_core/reactor.py:            def normalize_score(s):
./reactor_core/reactor.py:                if isinstance(s, bytes):
./reactor_core/reactor.py:                    s = s.decode()
./reactor_core/reactor.py:                s0 = str(s).strip()
./reactor_core/reactor.py:                # map common synonyms to canonical names (extend if needed)
./reactor_core/reactor.py:                syn = {
./reactor_core/reactor.py:                    "capture": "(n,gamma)",
./reactor_core/reactor.py:                    "ngamma": "(n,gamma)",
./reactor_core/reactor.py:                    "kappa-fission": "kappa-fission",
./reactor_core/reactor.py:                    "fission-q-prompt": "fission-q-prompt",
./reactor_core/reactor.py:                    "fission-q-recoverable": "fission-q-recoverable",
./reactor_core/reactor.py:                }
./reactor_core/reactor.py:                # if s is a plain integer string like "102", keep as-is (OpenMC accepts ints), but map known synonyms
./reactor_core/reactor.py:                s_lower = s0.lower()
./reactor_core/reactor.py:                if s_lower in syn:
./reactor_core/reactor.py:                    return syn[s_lower]
./reactor_core/reactor.py:                return s0
./reactor_core/reactor.py:
./reactor_core/reactor.py:            if scores:
./reactor_core/reactor.py:                seen = set()
./reactor_core/reactor.py:                norm_scores = []
./reactor_core/reactor.py:                for sc in scores:
./reactor_core/reactor.py:                    scn = normalize_score(sc)
./reactor_core/reactor.py:                    if scn in seen:
./reactor_core/reactor.py:                        # skip duplicate
./reactor_core/reactor.py:                        continue
./reactor_core/reactor.py:                    seen.add(scn)
./reactor_core/reactor.py:                    norm_scores.append(scn)
./reactor_core/reactor.py:                scores = norm_scores
./reactor_core/reactor.py:
./reactor_core/reactor.py:            # If scores is empty after normalization, skip tally
./reactor_core/reactor.py:            if scores is None or len(scores) == 0:
./reactor_core/reactor.py:                print(f"[WARN] Not adding tally '{name}' because no valid scores after normalization.")
./reactor_core/reactor.py:                return None
./reactor_core/reactor.py:
./reactor_core/reactor.py:            try:
./reactor_core/reactor.py:                t = openmc.Tally(name=name)
./reactor_core/reactor.py:                if filters:
./reactor_core/reactor.py:                    t.filters = filters
./reactor_core/reactor.py:                if nuclides:
./reactor_core/reactor.py:                    t.nuclides = nuclides
./reactor_core/reactor.py:                t.scores = scores  # set normalized unique list
./reactor_core/reactor.py:                tallies.append(t)
./reactor_core/reactor.py:                return t
./reactor_core/reactor.py:            except Exception as e:
./reactor_core/reactor.py:                print(f"[WARN] Could not create tally '{name}' with scores {scores}: {e}")
./reactor_core/reactor.py:                return None
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # common filters
./reactor_core/reactor.py:        cell_filter = openmc.CellFilter(fuel_cell)
./reactor_core/reactor.py:        neutron_filter = openmc.ParticleFilter("neutron")
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # coarse 3D mesh over the whole outer sphere box (used by many mesh tallies)
./reactor_core/reactor.py:        mesh = openmc.RegularMesh()
./reactor_core/reactor.py:        mesh.dimension = [self.NX, self.NY, self.NZ]
./reactor_core/reactor.py:        mesh.lower_left = [
./reactor_core/reactor.py:            -self.OUTER_RADIUS + self.MESH_MARGIN,
./reactor_core/reactor.py:            -self.OUTER_RADIUS + self.MESH_MARGIN,
./reactor_core/reactor.py:            -self.OUTER_RADIUS + self.MESH_MARGIN,
./reactor_core/reactor.py:        ]
./reactor_core/reactor.py:        mesh.upper_right = [
./reactor_core/reactor.py:            self.OUTER_RADIUS - self.MESH_MARGIN,
./reactor_core/reactor.py:            self.OUTER_RADIUS - self.MESH_MARGIN,
./reactor_core/reactor.py:            self.OUTER_RADIUS - self.MESH_MARGIN,
./reactor_core/reactor.py:        ]
./reactor_core/reactor.py:        mesh_filter = openmc.MeshFilter(mesh)
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # surface filter (outer boundary) and mesh-surface filter
./reactor_core/reactor.py:        surf_filter = openmc.SurfaceFilter(outer_sphere)
./reactor_core/reactor.py:        try:
./reactor_core/reactor.py:            mesh_surf_filter = openmc.MeshSurfaceFilter(mesh)  # may not be needed; safe try
./reactor_core/reactor.py:        except Exception:
./reactor_core/reactor.py:            mesh_surf_filter = None
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # energy bins for coarse spectrum / pulse-height use
./reactor_core/reactor.py:        energy_bins = [0.0, 1e-5, 0.5, 20.0]
./reactor_core/reactor.py:        energy_filter = openmc.EnergyFilter(energy_bins)
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 1) Basic flux and reaction tallies ----------
./reactor_core/reactor.py:        add_tally_safe(
./reactor_core/reactor.py:            "cell_flux",
./reactor_core/reactor.py:            filters=[cell_filter, neutron_filter],
./reactor_core/reactor.py:            scores=["flux"],
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # per-nuclide reaction rates (useful for depletion). Start with main actinides; add more as needed.
./reactor_core/reactor.py:        add_tally_safe(
./reactor_core/reactor.py:            "nuclide_rates",
./reactor_core/reactor.py:            filters=[cell_filter, neutron_filter],
./reactor_core/reactor.py:            nuclides=["U235", "U238", "Pu239", "Pu241"],  # adjust list to what you track
./reactor_core/reactor.py:            scores=["fission", "nu-fission", "absorption"],
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # detailed fission/neutron production splits
./reactor_core/reactor.py:        add_tally_safe(
./reactor_core/reactor.py:            "fission_production",
./reactor_core/reactor.py:            filters=[cell_filter, neutron_filter],
./reactor_core/reactor.py:            scores=["fission", "nu-fission", "prompt-nu-fission", "delayed-nu-fission"],
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # scatter and nu-scatter
./reactor_core/reactor.py:        add_tally_safe(
./reactor_core/reactor.py:            "scatter_rates",
./reactor_core/reactor.py:            filters=[cell_filter, neutron_filter],
./reactor_core/reactor.py:            scores=["scatter", "nu-scatter"],
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # specific reaction channels (use named scores where supported)
./reactor_core/reactor.py:        # Radiative capture: try common names; if unsupported it will be skipped
./reactor_core/reactor.py:        # add_tally_safe("radiative_capture", filters=[cell_filter], scores=["(n,gamma)", "102"])
./reactor_core/reactor.py:        add_tally_safe("radiative_capture", filters=[cell_filter, neutron_filter], scores=["(n,gamma)"])
./reactor_core/reactor.py:
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # examples of other specific channels often useful in depletion or activation:
./reactor_core/reactor.py:        add_tally_safe("reaction_n2n", filters=[cell_filter, neutron_filter], scores=["(n,2n)"])  # MT numbers vary; may be skipped
./reactor_core/reactor.py:        add_tally_safe("reaction_np_na", filters=[cell_filter, neutron_filter], scores=["(n,np)", "(n,2n)"])  # illustrative
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 2) Energy / spectrum tallies ----------
./reactor_core/reactor.py:        add_tally_safe(
./reactor_core/reactor.py:            "spectrum_flux",
./reactor_core/reactor.py:            filters=[cell_filter, energy_filter, neutron_filter],
./reactor_core/reactor.py:            scores=["flux"],
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 3) Heating and energy deposition (global + mesh) ----------
./reactor_core/reactor.py:        add_tally_safe(
./reactor_core/reactor.py:            "heating",
./reactor_core/reactor.py:            filters=[cell_filter, neutron_filter],
./reactor_core/reactor.py:            scores=["heating", "heating-local", "kappa-fission", "fission-q-prompt", "fission-q-recoverable"],
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:
./reactor_core/reactor.py:        add_tally_safe(
./reactor_core/reactor.py:            "mesh_heating",
./reactor_core/reactor.py:            filters=[mesh_filter, neutron_filter],
./reactor_core/reactor.py:            scores=["heating", "kappa-fission"],
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 4) Mesh flux (spatial shape) ----------
./reactor_core/reactor.py:        add_tally_safe(
./reactor_core/reactor.py:            "mesh_flux",
./reactor_core/reactor.py:            filters=[mesh_filter, neutron_filter],
./reactor_core/reactor.py:            scores=["flux"],
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 5) Currents & leakage ----------
./reactor_core/reactor.py:        add_tally_safe(
./reactor_core/reactor.py:            "surface_current",
./reactor_core/reactor.py:            filters=[surf_filter, neutron_filter],
./reactor_core/reactor.py:            scores=["current"],
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:
./reactor_core/reactor.py:        if mesh_surf_filter is not None:
./reactor_core/reactor.py:            add_tally_safe(
./reactor_core/reactor.py:                "mesh_surface_current",
./reactor_core/reactor.py:                filters=[mesh_surf_filter, neutron_filter],
./reactor_core/reactor.py:                scores=["current"],
./reactor_core/reactor.py:            )
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 6) Diagnostic / tally quality ----------
./reactor_core/reactor.py:        add_tally_safe("events", filters=[cell_filter, neutron_filter], scores=["events"])
./reactor_core/reactor.py:        add_tally_safe("inverse_velocity", filters=[cell_filter, neutron_filter], scores=["inverse-velocity"])
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 7) Damage / pulse-height / decay-rate ----------
./reactor_core/reactor.py:        add_tally_safe("damage_energy", filters=[cell_filter, neutron_filter], scores=["damage-energy"])
./reactor_core/reactor.py:        add_tally_safe("pulse_height", filters=[cell_filter, energy_filter], scores=["pulse-height"])
./reactor_core/reactor.py:        add_tally_safe("decay_rate", filters=[cell_filter, neutron_filter], scores=["decay-rate"])
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 8) Delayed / prompt energy/neutron tallies ----------
./reactor_core/reactor.py:        add_tally_safe("delayed_prompt_split", filters=[cell_filter, neutron_filter], scores=["prompt-nu-fission", "delayed-nu-fission"])
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 9) kappa / fission energy tallies ----------
./reactor_core/reactor.py:        add_tally_safe("kappa_fission", filters=[cell_filter, neutron_filter], scores=["kappa-fission", "fission-q-prompt", "fission-q-recoverable"])
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 10) Damage / activation specifics ----------
./reactor_core/reactor.py:        # If you track activation products or specific ENDF MT channels for transmutation, include them:
./reactor_core/reactor.py:        # Example: MT=102 is (n,gamma). You can add arbitrary MT numbers if your library supports them.
./reactor_core/reactor.py:        add_tally_safe("mt_102_ngamma", filters=[cell_filter, neutron_filter], scores=["102",])
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 11) Mesh-based scoring for diagnostic leakage / streaming ----------
./reactor_core/reactor.py:        if mesh_surf_filter is not None:
./reactor_core/reactor.py:            add_tally_safe("mesh_partial_currents", filters=[mesh_surf_filter, neutron_filter], scores=["current"])
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 12) Per-nuclide detailed channels for depletion (explicit) ----------
./reactor_core/reactor.py:        # It's often necessary to request per-nuclide channels needed for your depletion chain.
./reactor_core/reactor.py:        # Example: for xenon/I chains and actinide transmutation:
./reactor_core/reactor.py:        add_tally_safe(
./reactor_core/reactor.py:            "depletion_channels_U235",
./reactor_core/reactor.py:            filters=[cell_filter, neutron_filter],
./reactor_core/reactor.py:            nuclides=["U235"],
./reactor_core/reactor.py:            scores=["fission", "absorption", "(n,gamma)", "nu-fission"],
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:        add_tally_safe(
./reactor_core/reactor.py:            "depletion_channels_U238",
./reactor_core/reactor.py:            filters=[cell_filter, neutron_filter],
./reactor_core/reactor.py:            nuclides=["U238"],
./reactor_core/reactor.py:            scores=["fission", "absorption", "(n,gamma)"],
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:        # add similar per-nuclide tallies for Pu239, Xe135, I135, etc. as needed:
./reactor_core/reactor.py:        # add_tally_safe("depletion_Xe135", filters=[cell_filter], nuclides=["Xe135"], scores=["(n,gamma)","absorption"])
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # # ---------- 13) Photon/gamma tallies (if doing gamma heating / dose) ----------
./reactor_core/reactor.py:        # add_tally_safe(
./reactor_core/reactor.py:        #     "photon_pulse_height",
./reactor_core/reactor.py:        #     filters=[cell_filter, energy_filter],
./reactor_core/reactor.py:        #     scores=["pulse-height"],
./reactor_core/reactor.py:        # )
./reactor_core/reactor.py:        # add_tally_safe("photon_heating", filters=[cell_filter], scores=["heating"])
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 14) Safety: always export everything that was successfully created ----------
./reactor_core/reactor.py:        # Note: add_tally_safe prints warnings for those scores not supported by the current OpenMC/data combo.
./reactor_core/reactor.py:        tallies.export_to_xml()
./reactor_core/reactor.py:        print("[INFO] build_tallies: exported tallies.xml with available tallies (unsupported scores were skipped).")
./reactor_core/reactor.py:        return tallies
./reactor_core/reactor.py:
./reactor_core/reactor.py:
./reactor_core/reactor.py:    # def build_tallies(self, fuel_cell, outer_sphere):
./reactor_core/reactor.py:    #     tallies = openmc.Tallies()
./reactor_core/reactor.py:    #
./reactor_core/reactor.py:    #     # cell filter
./reactor_core/reactor.py:    #     cell_filter = openmc.CellFilter(fuel_cell)
./reactor_core/reactor.py:    #
./reactor_core/reactor.py:    #     # SAFE scores only: do not include 'capture' (some OpenMC versions reject it)
./reactor_core/reactor.py:    #     # We'll compute capture = absorption - fission in post-processing.
./reactor_core/reactor.py:    #     t_nuclide = openmc.Tally(name="nuclide_rates")
./reactor_core/reactor.py:    #     t_nuclide.filters = [cell_filter]
./reactor_core/reactor.py:    #     t_nuclide.nuclides = ["U235", "U238"]
./reactor_core/reactor.py:    #     t_nuclide.scores = ["fission", "nu-fission", "absorption"]
./reactor_core/reactor.py:    #     tallies.append(t_nuclide)
./reactor_core/reactor.py:    #
./reactor_core/reactor.py:    #     # heating (power deposition) per cell
./reactor_core/reactor.py:    #     t_heating = openmc.Tally(name="heating")
./reactor_core/reactor.py:    #     t_heating.filters = [cell_filter]
./reactor_core/reactor.py:    #     t_heating.scores = ["heating"]
./reactor_core/reactor.py:    #     tallies.append(t_heating)
./reactor_core/reactor.py:    #
./reactor_core/reactor.py:    #     # mesh tallies (coarse 3D mesh)
./reactor_core/reactor.py:    #     mesh = openmc.RegularMesh()
./reactor_core/reactor.py:    #     mesh.dimension = [self.NX, self.NY, self.NZ]
./reactor_core/reactor.py:    #     # keep mesh slightly inside the sphere to avoid boundary equality issues
./reactor_core/reactor.py:    #     mesh.lower_left = [
./reactor_core/reactor.py:    #         -self.OUTER_RADIUS + self.MESH_MARGIN,
./reactor_core/reactor.py:    #         -self.OUTER_RADIUS + self.MESH_MARGIN,
./reactor_core/reactor.py:    #         -self.OUTER_RADIUS + self.MESH_MARGIN,
./reactor_core/reactor.py:    #     ]
./reactor_core/reactor.py:    #     mesh.upper_right = [
./reactor_core/reactor.py:    #         self.OUTER_RADIUS - self.MESH_MARGIN,
./reactor_core/reactor.py:    #         self.OUTER_RADIUS - self.MESH_MARGIN,
./reactor_core/reactor.py:    #         self.OUTER_RADIUS - self.MESH_MARGIN,
./reactor_core/reactor.py:    #     ]
./reactor_core/reactor.py:    #     mesh_filter = openmc.MeshFilter(mesh)
./reactor_core/reactor.py:    #
./reactor_core/reactor.py:    #     t_mesh_flux = openmc.Tally(name="mesh_flux")
./reactor_core/reactor.py:    #     t_mesh_flux.filters = [mesh_filter]
./reactor_core/reactor.py:    #     t_mesh_flux.scores = ["flux"]
./reactor_core/reactor.py:    #     tallies.append(t_mesh_flux)
./reactor_core/reactor.py:    #
./reactor_core/reactor.py:    #     t_mesh_heating = openmc.Tally(name="mesh_heating")
./reactor_core/reactor.py:    #     t_mesh_heating.filters = [mesh_filter]
./reactor_core/reactor.py:    #     t_mesh_heating.scores = ["heating"]
./reactor_core/reactor.py:    #     tallies.append(t_mesh_heating)
./reactor_core/reactor.py:    #
./reactor_core/reactor.py:    #     # surface current for outer sphere (leakage diagnostic)
./reactor_core/reactor.py:    #     surf_filter = openmc.SurfaceFilter(outer_sphere)
./reactor_core/reactor.py:    #     t_current = openmc.Tally(name="surface_current")
./reactor_core/reactor.py:    #     t_current.filters = [surf_filter]
./reactor_core/reactor.py:    #     t_current.scores = ["current"]
./reactor_core/reactor.py:    #     tallies.append(t_current)
./reactor_core/reactor.py:    #
./reactor_core/reactor.py:    #     # energy-binned spectrum (coarse)
./reactor_core/reactor.py:    #     energy_bins = [0.0, 1e-5, 0.5, 20.0]
./reactor_core/reactor.py:    #     energy_filter = openmc.EnergyFilter(energy_bins)
./reactor_core/reactor.py:    #     t_spectrum = openmc.Tally(name="spectrum")
./reactor_core/reactor.py:    #     t_spectrum.filters = [cell_filter, energy_filter]
./reactor_core/reactor.py:    #     t_spectrum.scores = ["flux"]
./reactor_core/reactor.py:    #     tallies.append(t_spectrum)
./reactor_core/reactor.py:    #
./reactor_core/reactor.py:    #     tallies.export_to_xml()
./reactor_core/reactor.py:    #     return tallies
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def try_plot_geometry(self, geom, filename="geom_xy.png"):
./reactor_core/reactor.py:        # Produce an XY plot to inspect geometry visually
./reactor_core/reactor.py:        try:
./reactor_core/reactor.py:            p = openmc.Plot()
./reactor_core/reactor.py:            p.filename = filename.split(".")[0]
./reactor_core/reactor.py:            p.width = (2 * self.OUTER_RADIUS, 2 * self.OUTER_RADIUS)
./reactor_core/reactor.py:            p.pixels = (600, 600)
./reactor_core/reactor.py:            p.origin = (0.0, 0.0, 0.0)
./reactor_core/reactor.py:            p.basis = "xy"
./reactor_core/reactor.py:            plots = openmc.Plots([p])
./reactor_core/reactor.py:            plots.export_to_xml()
./reactor_core/reactor.py:            p.to_ipython_image()
./reactor_core/reactor.py:
./reactor_core/reactor.py:            # OpenMC writes PNG to default 'plots' directory or working dir depending on version
./reactor_core/reactor.py:            print(
./reactor_core/reactor.py:                f"[INFO] Geometry plot requested (check geom_xy.png or plots/geom_xy.png)."
./reactor_core/reactor.py:            )
./reactor_core/reactor.py:        except Exception as e:
./reactor_core/reactor.py:            print("[WARN] Could not create geometry plot:", e)
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def run_openmc_safe(self, run_depletion=False, depletion_days=0.0, sp=None):
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        Run OpenMC (transport). If run_depletion True, attempt a single depletion step (safe fallback).
./reactor_core/reactor.py:        Wrap in try/except to capture runtime errors (lost particles, invalid tally scores).
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        try:
./reactor_core/reactor.py:            # plain transport run
./reactor_core/reactor.py:            print(
./reactor_core/reactor.py:                f"[RUN] Starting OpenMC transport at {datetime.utcnow().isoformat()} UTC"
./reactor_core/reactor.py:            )
./reactor_core/reactor.py:            if sp:
./reactor_core/reactor.py:                openmc.run(
./reactor_core/reactor.py:                    mpi_args=["mpiexec", "--use-hwthread-cpus", "-n", "4"],
./reactor_core/reactor.py:                    restart_file=sp
./reactor_core/reactor.py:                )  # allow executor to use mpi args from environment
./reactor_core/reactor.py:            else:
./reactor_core/reactor.py:                openmc.run(
./reactor_core/reactor.py:                    mpi_args=["mpiexec", "--use-hwthread-cpus", "-n", "4"]
./reactor_core/reactor.py:                )  # allow executor to use mpi args from environment
./reactor_core/reactor.py:            return 0
./reactor_core/reactor.py:        except RuntimeError as rte:
./reactor_core/reactor.py:            msg = str(rte)
./reactor_core/reactor.py:            print("[ERROR] OpenMC runtime error:\n", msg)
./reactor_core/reactor.py:            # detect common causes and give immediate advice
./reactor_core/reactor.py:            if (
./reactor_core/reactor.py:                "lost particles" in msg.lower()
./reactor_core/reactor.py:                or "Maximum number of lost particles" in msg
./reactor_core/reactor.py:            ):
./reactor_core/reactor.py:                print(
./reactor_core/reactor.py:                    "\nA. Likely cause: geometry gap/overlap causing particles to be in no cell."
./reactor_core/reactor.py:                )
./reactor_core/reactor.py:                print(
./reactor_core/reactor.py:                    "   - Ensure every fuel/moderator/void region is bounded (e.g., fuel_cell.region = -fuel_cyl & -outer_sphere)."
./reactor_core/reactor.py:                )
./reactor_core/reactor.py:                print(
./reactor_core/reactor.py:                    "   - Run geom.check_overlaps() and create a small debug transport (fewer particles) to inspect."
./reactor_core/reactor.py:                )
./reactor_core/reactor.py:            if "Invalid tally score" in msg:
./reactor_core/reactor.py:                print(
./reactor_core/reactor.py:                    "\nB. Invalid tally score detected. Use safe scores (flux, fission, nu-fission, absorption, heating, current)."
./reactor_core/reactor.py:                )
./reactor_core/reactor.py:            # produce geometry checks and a small debug plot to help diagnose
./reactor_core/reactor.py:            try:
./reactor_core/reactor.py:                geom = openmc.Geometry.from_xml()  # read geometry
./reactor_core/reactor.py:                print("[INFO] Running geom.check_overlaps() for diagnostics...")
./reactor_core/reactor.py:                # geom.check_overlaps()
./reactor_core/reactor.py:            except Exception as e:
./reactor_core/reactor.py:                print("[WARN] geom.check_overlaps() failed:", e)
./reactor_core/reactor.py:            try:
./reactor_core/reactor.py:                try_plot_geometry(openmc.Geometry.from_xml())
./reactor_core/reactor.py:            except Exception:
./reactor_core/reactor.py:                pass
./reactor_core/reactor.py:            raise
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def latest_statepoint(
./reactor_core/reactor.py:        self,
./reactor_core/reactor.py:    ):
./reactor_core/reactor.py:        sps = sorted(glob.glob("statepoint.*.h5"))
./reactor_core/reactor.py:        r1 = sps[-1] if sps else None
./reactor_core/reactor.py:        if sps:
./reactor_core/reactor.py:            sps_max_batch = max([int(i.split(".")[1]) for i in sps])
./reactor_core/reactor.py:            return (r1, sps_max_batch,)
./reactor_core/reactor.py:        else:
./reactor_core/reactor.py:            return (r1, 0)
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def postprocess_all_tallies(self, sp_file):
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        Robust reader for the comprehensive tally set (the ~25 tallies).
./reactor_core/reactor.py:        Populates self.data_dict with raw means/stds and useful derived quantities.
./reactor_core/reactor.py:        NOTE: tallies are returned in *per source-particle* units. This function
./reactor_core/reactor.py:        does NOT perform physical normalization to W or neutrons/s. Set a scale
./reactor_core/reactor.py:        (e.g. via self.data_dict['scale_JperSource_to_W'] or power_target) afterwards.
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        # import numpy as np
./reactor_core/reactor.py:        # import os
./reactor_core/reactor.py:        # from datetime import datetime
./reactor_core/reactor.py:
./reactor_core/reactor.py:        print(f"[POST] Reading statepoint: {sp_file}")
./reactor_core/reactor.py:        sp = openmc.StatePoint(sp_file)
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # timestamp / provenance
./reactor_core/reactor.py:        try:
./reactor_core/reactor.py:            mtime = os.path.getmtime(sp_file)
./reactor_core/reactor.py:            self.data_dict["snapshot_time"] = datetime.utcfromtimestamp(mtime).isoformat() + "Z"
./reactor_core/reactor.py:        except Exception:
./reactor_core/reactor.py:            self.data_dict["snapshot_time"] = None
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # --- k_eff ---
./reactor_core/reactor.py:        try:
./reactor_core/reactor.py:            k_res = sp.k_combined
./reactor_core/reactor.py:            try:
./reactor_core/reactor.py:                k_val = k_res.nominal_value
./reactor_core/reactor.py:                k_std = k_res.std_dev
./reactor_core/reactor.py:            except Exception:
./reactor_core/reactor.py:                k_val = float(k_res)
./reactor_core/reactor.py:                k_std = None
./reactor_core/reactor.py:        except Exception:
./reactor_core/reactor.py:            try:
./reactor_core/reactor.py:                k_val = float(sp.k_combined[0].n)
./reactor_core/reactor.py:                k_std = float(sp.k_combined[0].s)
./reactor_core/reactor.py:            except Exception:
./reactor_core/reactor.py:                k_val = None
./reactor_core/reactor.py:                k_std = None
./reactor_core/reactor.py:        print(f"  k_eff = {k_val}  (std = {k_std})")
./reactor_core/reactor.py:        self.data_dict["k_val"] = k_val
./reactor_core/reactor.py:        self.data_dict["k_std"] = k_std
./reactor_core/reactor.py:        # derived: reactivity (if available)
./reactor_core/reactor.py:        try:
./reactor_core/reactor.py:            if k_val is not None:
./reactor_core/reactor.py:                rho = (k_val - 1.0) / k_val
./reactor_core/reactor.py:                self.data_dict["rho"] = rho
./reactor_core/reactor.py:                self.data_dict["rho_std"] = (1.0 / (k_val**2)) * k_std if k_std is not None else None
./reactor_core/reactor.py:            else:
./reactor_core/reactor.py:                self.data_dict["rho"] = None
./reactor_core/reactor.py:                self.data_dict["rho_std"] = None
./reactor_core/reactor.py:        except Exception:
./reactor_core/reactor.py:            self.data_dict["rho"] = None
./reactor_core/reactor.py:            self.data_dict["rho_std"] = None
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # helper to find tally by name robustly
./reactor_core/reactor.py:        def find_tally(name):
./reactor_core/reactor.py:            for tid, t in sp.tallies.items():
./reactor_core/reactor.py:                try:
./reactor_core/reactor.py:                    if getattr(t, "name", None) == name:
./reactor_core/reactor.py:                        return t
./reactor_core/reactor.py:                except Exception:
./reactor_core/reactor.py:                    pass
./reactor_core/reactor.py:            return None
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # helper to safely extract flattened mean/std (returns (mean_array, std_array) or (None,None))
./reactor_core/reactor.py:        def get_mean_std(tally):
./reactor_core/reactor.py:            try:
./reactor_core/reactor.py:                mean = np.asarray(tally.mean).flatten()
./reactor_core/reactor.py:                std = np.asarray(tally.std_dev).flatten()
./reactor_core/reactor.py:                return mean, std
./reactor_core/reactor.py:            except Exception:
./reactor_core/reactor.py:                return None, None
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # store which tallies were found
./reactor_core/reactor.py:        self.data_dict["tallies_present"] = []
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 1) nuclide_rates (per-nuclide fission/absorption) ----------
./reactor_core/reactor.py:        t = find_tally("nuclide_rates")
./reactor_core/reactor.py:        if t is not None:
./reactor_core/reactor.py:            self.data_dict["tallies_present"].append("nuclide_rates")
./reactor_core/reactor.py:            try:
./reactor_core/reactor.py:                mean = np.asarray(t.mean)
./reactor_core/reactor.py:                std  = np.asarray(t.std_dev)
./reactor_core/reactor.py:                # deduce scores & nuclides meta
./reactor_core/reactor.py:                scores = list(t.scores)
./reactor_core/reactor.py:                nuclides = [n.decode() if isinstance(n, bytes) else n for n in t.nuclides]
./reactor_core/reactor.py:                self.data_dict["nuclide_rates_scores"] = scores
./reactor_core/reactor.py:                self.data_dict["nuclide_rates_nuclides"] = nuclides
./reactor_core/reactor.py:
./reactor_core/reactor.py:                flat_mean = mean.flatten()
./reactor_core/reactor.py:                flat_std  = std.flatten()
./reactor_core/reactor.py:                # Attempt reshape: (n_filters, n_scores, n_nuclides)
./reactor_core/reactor.py:                try:
./reactor_core/reactor.py:                    arr = flat_mean.reshape((-1, len(scores), len(nuclides)))
./reactor_core/reactor.py:                    arrs = flat_std.reshape((-1, len(scores), len(nuclides)))
./reactor_core/reactor.py:                    # take first filter index (typical)
./reactor_core/reactor.py:                    data_mean = arr[0]
./reactor_core/reactor.py:                    data_std  = arrs[0]
./reactor_core/reactor.py:                    # save per-score arrays keyed by score
./reactor_core/reactor.py:                    for si, score in enumerate(scores):
./reactor_core/reactor.py:                        key_mean = f"nuclide_rates_{score}_mean"
./reactor_core/reactor.py:                        key_std  = f"nuclide_rates_{score}_std"
./reactor_core/reactor.py:                        self.data_dict[key_mean] = data_mean[si, :].astype(float)
./reactor_core/reactor.py:                        self.data_dict[key_std]  = data_std[si, :].astype(float)
./reactor_core/reactor.py:                    # compute capture = absorption - fission if both exist
./reactor_core/reactor.py:                    if ("absorption" in scores) and ("fission" in scores):
./reactor_core/reactor.py:                        abs_idx = scores.index("absorption")
./reactor_core/reactor.py:                        fiss_idx = scores.index("fission")
./reactor_core/reactor.py:                        abs_mean = data_mean[abs_idx, :]
./reactor_core/reactor.py:                        abs_std = data_std[abs_idx, :]
./reactor_core/reactor.py:                        fiss_mean = data_mean[fiss_idx, :]
./reactor_core/reactor.py:                        fiss_std = data_std[fiss_idx, :]
./reactor_core/reactor.py:                        cap_mean = abs_mean - fiss_mean
./reactor_core/reactor.py:                        cap_std = np.sqrt(abs_std**2 + fiss_std**2)
./reactor_core/reactor.py:                        self.data_dict["nuclide_rates_capture_mean"] = cap_mean.astype(float)
./reactor_core/reactor.py:                        self.data_dict["nuclide_rates_capture_std"]  = cap_std.astype(float)
./reactor_core/reactor.py:                    # print summary
./reactor_core/reactor.py:                    print("  nuclide_rates found for nuclides:", nuclides)
./reactor_core/reactor.py:                    for i, nuc in enumerate(nuclides):
./reactor_core/reactor.py:                        fmean = self.data_dict.get("nuclide_rates_fission_mean", None)
./reactor_core/reactor.py:                        if fmean is not None:
./reactor_core/reactor.py:                            print(f"    {nuc}: fission = {fmean[i]:.6e}")
./reactor_core/reactor.py:                except Exception as e:
./reactor_core/reactor.py:                    # fallback: save flattened arrays
./reactor_core/reactor.py:                    self.data_dict["nuclide_rates_flat_mean"] = flat_mean.astype(float)
./reactor_core/reactor.py:                    self.data_dict["nuclide_rates_flat_std"]  = flat_std.astype(float)
./reactor_core/reactor.py:                    print("[WARN] Could not reshape nuclide_rates to (filters,scores,nuclides):", e)
./reactor_core/reactor.py:            except Exception as e:
./reactor_core/reactor.py:                print("[WARN] Error reading nuclide_rates:", e)
./reactor_core/reactor.py:        else:
./reactor_core/reactor.py:            print("  nuclide_rates tally missing.")
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 2) fission_production (fission / nu-fission / prompt / delayed) ----------
./reactor_core/reactor.py:        t = find_tally("fission_production")
./reactor_core/reactor.py:        if t is not None:
./reactor_core/reactor.py:            self.data_dict["tallies_present"].append("fission_production")
./reactor_core/reactor.py:            m, s = get_mean_std(t)
./reactor_core/reactor.py:            self.data_dict["fission_production_mean"] = m
./reactor_core/reactor.py:            self.data_dict["fission_production_std"]  = s
./reactor_core/reactor.py:        # ---------- 3) scatter_rates ----------
./reactor_core/reactor.py:        t = find_tally("scatter_rates")
./reactor_core/reactor.py:        if t is not None:
./reactor_core/reactor.py:            self.data_dict["tallies_present"].append("scatter_rates")
./reactor_core/reactor.py:            m, s = get_mean_std(t)
./reactor_core/reactor.py:            self.data_dict["scatter_rates_mean"] = m
./reactor_core/reactor.py:            self.data_dict["scatter_rates_std"]  = s
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 4) radiative_capture / mt_102_ngamma ----------
./reactor_core/reactor.py:        t = find_tally("radiative_capture")
./reactor_core/reactor.py:        if t is not None:
./reactor_core/reactor.py:            self.data_dict["tallies_present"].append("radiative_capture")
./reactor_core/reactor.py:            m, s = get_mean_std(t)
./reactor_core/reactor.py:            self.data_dict["radiative_capture_mean"] = m
./reactor_core/reactor.py:            self.data_dict["radiative_capture_std"]  = s
./reactor_core/reactor.py:        t = find_tally("mt_102_ngamma")
./reactor_core/reactor.py:        if t is not None:
./reactor_core/reactor.py:            self.data_dict["tallies_present"].append("mt_102_ngamma")
./reactor_core/reactor.py:            m, s = get_mean_std(t)
./reactor_core/reactor.py:            self.data_dict["mt_102_ngamma_mean"] = m
./reactor_core/reactor.py:            self.data_dict["mt_102_ngamma_std"]  = s
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 5) spectrum_flux (energy-binned flux) ----------
./reactor_core/reactor.py:        t = find_tally("spectrum_flux")
./reactor_core/reactor.py:        if t is not None:
./reactor_core/reactor.py:            self.data_dict["tallies_present"].append("spectrum_flux")
./reactor_core/reactor.py:            m, s = get_mean_std(t)
./reactor_core/reactor.py:            self.data_dict["spectrum_flux_mean"] = m
./reactor_core/reactor.py:            self.data_dict["spectrum_flux_std"]  = s
./reactor_core/reactor.py:            # if energy_filter use, store number of bins
./reactor_core/reactor.py:            try:
./reactor_core/reactor.py:                # number of bins = size / filters? best-effort:
./reactor_core/reactor.py:                self.data_dict["spectrum_num_bins"] = len(m)
./reactor_core/reactor.py:                print(f"  spectrum_flux: {len(m)} entries")
./reactor_core/reactor.py:            except Exception:
./reactor_core/reactor.py:                pass
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 6) heating (cell) and mesh_heating ----------
./reactor_core/reactor.py:        t = find_tally("heating")
./reactor_core/reactor.py:        if t is not None:
./reactor_core/reactor.py:            self.data_dict["tallies_present"].append("heating")
./reactor_core/reactor.py:            hm, hs = get_mean_std(t)
./reactor_core/reactor.py:            self.data_dict["heating_mean"] = hm
./reactor_core/reactor.py:            self.data_dict["heating_std"]  = hs
./reactor_core/reactor.py:            # total heating per source (J per source) if heating is present:
./reactor_core/reactor.py:            try:
./reactor_core/reactor.py:                total_heating_per_source = float(np.sum(hm))
./reactor_core/reactor.py:                total_heating_std = float(np.sqrt(np.sum(hs**2)))
./reactor_core/reactor.py:                self.data_dict["total_heating_per_source_J"] = total_heating_per_source
./reactor_core/reactor.py:                self.data_dict["total_heating_per_source_std_J"] = total_heating_std
./reactor_core/reactor.py:                print(f"  heating sum (J per source) = {total_heating_per_source:.6e} ± {total_heating_std:.6e}")
./reactor_core/reactor.py:            except Exception:
./reactor_core/reactor.py:                pass
./reactor_core/reactor.py:        else:
./reactor_core/reactor.py:            print("  heating tally missing.")
./reactor_core/reactor.py:
./reactor_core/reactor.py:        t = find_tally("mesh_heating")
./reactor_core/reactor.py:        if t is not None:
./reactor_core/reactor.py:            self.data_dict["tallies_present"].append("mesh_heating")
./reactor_core/reactor.py:            mh_mean, mh_std = get_mean_std(t)
./reactor_core/reactor.py:            self.data_dict["mesh_heating_mean_flat"] = mh_mean
./reactor_core/reactor.py:            self.data_dict["mesh_heating_std_flat"]  = mh_std
./reactor_core/reactor.py:            # reshape to 3D if size matches NX*NY*NZ
./reactor_core/reactor.py:            try:
./reactor_core/reactor.py:                total_cells = int(self.NX * self.NY * self.NZ)
./reactor_core/reactor.py:                if mh_mean is not None and mh_mean.size >= total_cells:
./reactor_core/reactor.py:                    mh3 = np.asarray(mh_mean[:total_cells]).reshape((self.NX, self.NY, self.NZ))
./reactor_core/reactor.py:                    mh3s = np.asarray(mh_std[:total_cells]).reshape((self.NX, self.NY, self.NZ))
./reactor_core/reactor.py:                    self.data_dict["mesh_heating_mean_3d"] = mh3.astype(float)
./reactor_core/reactor.py:                    self.data_dict["mesh_heating_std_3d"]  = mh3s.astype(float)
./reactor_core/reactor.py:                    # compute simple peaking factor (max/avg) in mesh_heating if possible
./reactor_core/reactor.py:                    try:
./reactor_core/reactor.py:                        cell_powers = mh3
./reactor_core/reactor.py:                        peak = float(cell_powers.max())
./reactor_core/reactor.py:                        avg = float(cell_powers.mean())
./reactor_core/reactor.py:                        peaking = peak / avg if avg != 0 else None
./reactor_core/reactor.py:                        self.data_dict["mesh_heating_peak_W_per_source"] = peak
./reactor_core/reactor.py:                        self.data_dict["mesh_heating_avg_W_per_source"] = avg
./reactor_core/reactor.py:                        self.data_dict["mesh_heating_peaking"] = peaking
./reactor_core/reactor.py:                        print(f"  mesh_heating peaking (per-source) = {peaking}")
./reactor_core/reactor.py:                    except Exception:
./reactor_core/reactor.py:                        pass
./reactor_core/reactor.py:            except Exception as e:
./reactor_core/reactor.py:                print("[WARN] couldn't reshape mesh_heating:", e)
./reactor_core/reactor.py:        else:
./reactor_core/reactor.py:            print("  mesh_heating tally missing.")
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 7) mesh_flux ----------
./reactor_core/reactor.py:        t = find_tally("mesh_flux")
./reactor_core/reactor.py:        if t is not None:
./reactor_core/reactor.py:            self.data_dict["tallies_present"].append("mesh_flux")
./reactor_core/reactor.py:            mf, ms = get_mean_std(t)
./reactor_core/reactor.py:            self.data_dict["mesh_flux_mean_flat"] = mf
./reactor_core/reactor.py:            self.data_dict["mesh_flux_std_flat"]  = ms
./reactor_core/reactor.py:            try:
./reactor_core/reactor.py:                total_cells = int(self.NX * self.NY * self.NZ)
./reactor_core/reactor.py:                if mf is not None and mf.size >= total_cells:
./reactor_core/reactor.py:                    mf3 = np.asarray(mf[:total_cells]).reshape((self.NX, self.NY, self.NZ))
./reactor_core/reactor.py:                    ms3 = np.asarray(ms[:total_cells]).reshape((self.NX, self.NY, self.NZ))
./reactor_core/reactor.py:                    self.data_dict["mesh_flux_mean_3d"] = mf3.astype(float)
./reactor_core/reactor.py:                    self.data_dict["mesh_flux_std_3d"]  = ms3.astype(float)
./reactor_core/reactor.py:                    print(f"  mesh_flux shape: {(self.NX, self.NY, self.NZ)}")
./reactor_core/reactor.py:            except Exception as e:
./reactor_core/reactor.py:                print("[WARN] couldn't reshape mesh_flux:", e)
./reactor_core/reactor.py:        else:
./reactor_core/reactor.py:            print("  mesh_flux tally missing.")
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 8) surface_current & mesh_surface_current ----------
./reactor_core/reactor.py:        t = find_tally("surface_current")
./reactor_core/reactor.py:        if t is not None:
./reactor_core/reactor.py:            self.data_dict["tallies_present"].append("surface_current")
./reactor_core/reactor.py:            cm, cs = get_mean_std(t)
./reactor_core/reactor.py:            self.data_dict["surface_current_mean"] = cm
./reactor_core/reactor.py:            self.data_dict["surface_current_std"]  = cs
./reactor_core/reactor.py:            # sum leakage per-source
./reactor_core/reactor.py:            try:
./reactor_core/reactor.py:                leak = float(np.sum(cm))
./reactor_core/reactor.py:                self.data_dict["leakage_per_source"] = leak
./reactor_core/reactor.py:                print(f"  leakage (per-source, summed current) = {leak:.6e}")
./reactor_core/reactor.py:            except Exception:
./reactor_core/reactor.py:                pass
./reactor_core/reactor.py:        else:
./reactor_core/reactor.py:            print("  surface_current tally missing.")
./reactor_core/reactor.py:
./reactor_core/reactor.py:        t = find_tally("mesh_surface_current")
./reactor_core/reactor.py:        if t is not None:
./reactor_core/reactor.py:            self.data_dict["tallies_present"].append("mesh_surface_current")
./reactor_core/reactor.py:            mc_mean, mc_std = get_mean_std(t)
./reactor_core/reactor.py:            self.data_dict["mesh_surface_current_mean_flat"] = mc_mean
./reactor_core/reactor.py:            self.data_dict["mesh_surface_current_std_flat"]  = mc_std
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 9) events, inverse-velocity ----------
./reactor_core/reactor.py:        t = find_tally("events")
./reactor_core/reactor.py:        if t is not None:
./reactor_core/reactor.py:            self.data_dict["tallies_present"].append("events")
./reactor_core/reactor.py:            m, s = get_mean_std(t)
./reactor_core/reactor.py:            self.data_dict["events_mean"] = m
./reactor_core/reactor.py:            self.data_dict["events_std"]  = s
./reactor_core/reactor.py:
./reactor_core/reactor.py:        t = find_tally("inverse_velocity")
./reactor_core/reactor.py:        if t is not None:
./reactor_core/reactor.py:            self.data_dict["tallies_present"].append("inverse_velocity")
./reactor_core/reactor.py:            m, s = get_mean_std(t)
./reactor_core/reactor.py:            self.data_dict["inverse_velocity_mean"] = m
./reactor_core/reactor.py:            self.data_dict["inverse_velocity_std"]  = s
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 10) damage-energy, pulse-height, decay-rate ----------
./reactor_core/reactor.py:        t = find_tally("damage_energy")
./reactor_core/reactor.py:        if t is not None:
./reactor_core/reactor.py:            self.data_dict["tallies_present"].append("damage_energy")
./reactor_core/reactor.py:            m, s = get_mean_std(t)
./reactor_core/reactor.py:            self.data_dict["damage_energy_mean"] = m
./reactor_core/reactor.py:            self.data_dict["damage_energy_std"]  = s
./reactor_core/reactor.py:
./reactor_core/reactor.py:        t = find_tally("pulse_height")
./reactor_core/reactor.py:        if t is not None:
./reactor_core/reactor.py:            self.data_dict["tallies_present"].append("pulse_height")
./reactor_core/reactor.py:            m, s = get_mean_std(t)
./reactor_core/reactor.py:            self.data_dict["pulse_height_mean"] = m
./reactor_core/reactor.py:            self.data_dict["pulse_height_std"]  = s
./reactor_core/reactor.py:
./reactor_core/reactor.py:        t = find_tally("decay_rate")
./reactor_core/reactor.py:        if t is not None:
./reactor_core/reactor.py:            self.data_dict["tallies_present"].append("decay_rate")
./reactor_core/reactor.py:            m, s = get_mean_std(t)
./reactor_core/reactor.py:            self.data_dict["decay_rate_mean"] = m
./reactor_core/reactor.py:            self.data_dict["decay_rate_std"]  = s
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 11) delayed/prompt split ----------
./reactor_core/reactor.py:        t = find_tally("delayed_prompt_split")
./reactor_core/reactor.py:        if t is not None:
./reactor_core/reactor.py:            self.data_dict["tallies_present"].append("delayed_prompt_split")
./reactor_core/reactor.py:            m, s = get_mean_std(t)
./reactor_core/reactor.py:            self.data_dict["delayed_prompt_split_mean"] = m
./reactor_core/reactor.py:            self.data_dict["delayed_prompt_split_std"]  = s
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 12) kappa_fission / fission-q tallies ----------
./reactor_core/reactor.py:        t = find_tally("kappa_fission")
./reactor_core/reactor.py:        if t is not None:
./reactor_core/reactor.py:            self.data_dict["tallies_present"].append("kappa_fission")
./reactor_core/reactor.py:            m, s = get_mean_std(t)
./reactor_core/reactor.py:            self.data_dict["kappa_fission_mean"] = m
./reactor_core/reactor.py:            self.data_dict["kappa_fission_std"]  = s
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 13) depletion_channels_* tallies (examples) ----------
./reactor_core/reactor.py:        t = find_tally("depletion_channels_U235")
./reactor_core/reactor.py:        if t is not None:
./reactor_core/reactor.py:            self.data_dict["tallies_present"].append("depletion_channels_U235")
./reactor_core/reactor.py:            m, s = get_mean_std(t)
./reactor_core/reactor.py:            self.data_dict["depletion_U235_mean"] = m
./reactor_core/reactor.py:            self.data_dict["depletion_U235_std"]  = s
./reactor_core/reactor.py:
./reactor_core/reactor.py:        t = find_tally("depletion_channels_U238")
./reactor_core/reactor.py:        if t is not None:
./reactor_core/reactor.py:            self.data_dict["tallies_present"].append("depletion_channels_U238")
./reactor_core/reactor.py:            m, s = get_mean_std(t)
./reactor_core/reactor.py:            self.data_dict["depletion_U238_mean"] = m
./reactor_core/reactor.py:            self.data_dict["depletion_U238_std"]  = s
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 14) photon tallies (if present) ----------
./reactor_core/reactor.py:        t = find_tally("photon_pulse_height")
./reactor_core/reactor.py:        if t is not None:
./reactor_core/reactor.py:            self.data_dict["tallies_present"].append("photon_pulse_height")
./reactor_core/reactor.py:            m, s = get_mean_std(t)
./reactor_core/reactor.py:            self.data_dict["photon_pulse_height_mean"] = m
./reactor_core/reactor.py:            self.data_dict["photon_pulse_height_std"]  = s
./reactor_core/reactor.py:
./reactor_core/reactor.py:        t = find_tally("photon_heating")
./reactor_core/reactor.py:        if t is not None:
./reactor_core/reactor.py:            self.data_dict["tallies_present"].append("photon_heating")
./reactor_core/reactor.py:            m, s = get_mean_std(t)
./reactor_core/reactor.py:            self.data_dict["photon_heating_mean"] = m
./reactor_core/reactor.py:            self.data_dict["photon_heating_std"]  = s
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 15) fallback: any other tallies present in statepoint (collect names) ----------
./reactor_core/reactor.py:        try:
./reactor_core/reactor.py:            for tid, t in sp.tallies.items():
./reactor_core/reactor.py:                name = getattr(t, "name", None)
./reactor_core/reactor.py:                if name and name not in self.data_dict.get("tallies_present", []):
./reactor_core/reactor.py:                    # try to read means/std and add under generic key
./reactor_core/reactor.py:                    try:
./reactor_core/reactor.py:                        m, s = get_mean_std(t)
./reactor_core/reactor.py:                        key_mean = f"tally_{name}_mean"
./reactor_core/reactor.py:                        key_std  = f"tally_{name}_std"
./reactor_core/reactor.py:                        self.data_dict[key_mean] = m
./reactor_core/reactor.py:                        self.data_dict[key_std]  = s
./reactor_core/reactor.py:                        self.data_dict.setdefault("tallies_present", []).append(name)
./reactor_core/reactor.py:                        print(f"  (found additional tally '{name}')")
./reactor_core/reactor.py:                    except Exception:
./reactor_core/reactor.py:                        pass
./reactor_core/reactor.py:        except Exception:
./reactor_core/reactor.py:            pass
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # ---------- 16) Derived quantities & notes ----------
./reactor_core/reactor.py:        # Save a placeholder for scale conversions (user should set in pipeline)
./reactor_core/reactor.py:        # e.g. to convert J-per-source -> W set scale_JperSource_to_W = physical_power_W / total_heating_per_source_J
./reactor_core/reactor.py:        self.data_dict.setdefault("scale_JperSource_to_W", None)
./reactor_core/reactor.py:        self.data_dict.setdefault("power_target_W", None)  # optionally set by caller
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # If heating present and scale set, compute physical total power
./reactor_core/reactor.py:        try:
./reactor_core/reactor.py:            scale = self.data_dict.get("scale_JperSource_to_W", None)
./reactor_core/reactor.py:            if ("total_heating_per_source_J" in self.data_dict) and (scale is not None):
./reactor_core/reactor.py:                P = float(self.data_dict["total_heating_per_source_J"]) * float(scale)
./reactor_core/reactor.py:                P_std = float(self.data_dict.get("total_heating_per_source_std_J", 0.0)) * float(scale)
./reactor_core/reactor.py:                self.data_dict["total_power_W"] = P
./reactor_core/reactor.py:                self.data_dict["total_power_std_W"] = P_std
./reactor_core/reactor.py:                print(f"  total_power_W = {P:.6e} ± {P_std:.6e}")
./reactor_core/reactor.py:        except Exception:
./reactor_core/reactor.py:            pass
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # Basic QA printout
./reactor_core/reactor.py:        print("[POST] Tallies present:", ", ".join(self.data_dict.get("tallies_present", [])))
./reactor_core/reactor.py:        print("[POST] Stored keys in data_dict:", ", ".join(list(self.data_dict.keys())))
./reactor_core/reactor.py:
./reactor_core/reactor.py:        return self.data_dict
./reactor_core/reactor.py:
./reactor_core/reactor.py:    # constants
./reactor_core/reactor.py:    EV_TO_J = 1.602176634e-19
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def set_power_target(self, power_W):
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        Call this before running OpenMC or before postprocessing if you want to
./reactor_core/reactor.py:        normalize tallies to a specific plant power (Watts).
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        if power_W is None:
./reactor_core/reactor.py:            self.POWER_TARGET_W = None
./reactor_core/reactor.py:            print("[INFO] POWER_TARGET_W unset; no automatic scaling will be applied.")
./reactor_core/reactor.py:        else:
./reactor_core/reactor.py:            self.POWER_TARGET_W = float(power_W)
./reactor_core/reactor.py:            print(f"[INFO] POWER_TARGET_W set to {self.POWER_TARGET_W:.6e} W")
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def compute_scaling_and_apply(self):
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        After postprocessing tallies into self.data_dict (so keys like
./reactor_core/reactor.py:        'total_heating_per_source_J' or 'total_heating_per_source_eV' exist),
./reactor_core/reactor.py:        call this to compute `scale_JperSource_to_W` and to compute derived
./reactor_core/reactor.py:        physical quantities like total_power_W and scaled mesh/pin powers.
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        # ensure data_dict exists
./reactor_core/reactor.py:        if not hasattr(self, "data_dict") or self.data_dict is None:
./reactor_core/reactor.py:            raise RuntimeError("data_dict not found; run postprocess_all_tallies() first")
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # 1) Determine total heating per source in J (try multiple keys)
./reactor_core/reactor.py:        totJ = None
./reactor_core/reactor.py:        if "total_heating_per_source_J" in self.data_dict and self.data_dict["total_heating_per_source_J"] is not None:
./reactor_core/reactor.py:            totJ = float(self.data_dict["total_heating_per_source_J"])
./reactor_core/reactor.py:        elif "total_heating_per_source_eV" in self.data_dict and self.data_dict["total_heating_per_source_eV"] is not None:
./reactor_core/reactor.py:            totJ = float(self.data_dict["total_heating_per_source_eV"]) * EV_TO_J
./reactor_core/reactor.py:            # store converted value for clarity
./reactor_core/reactor.py:            self.data_dict["total_heating_per_source_J"] = totJ
./reactor_core/reactor.py:        else:
./reactor_core/reactor.py:            # try to derive from available heating_mean (which may be in eV/source)
./reactor_core/reactor.py:            if "heating_mean" in self.data_dict and self.data_dict["heating_mean"] is not None:
./reactor_core/reactor.py:                try:
./reactor_core/reactor.py:                    hm = np.asarray(self.data_dict["heating_mean"], dtype=float)
./reactor_core/reactor.py:                    # sum the per-cell heating (assumes heating_mean is in eV/source)
./reactor_core/reactor.py:                    tot_eV = float(hm.sum())
./reactor_core/reactor.py:                    totJ = tot_eV * EV_TO_J
./reactor_core/reactor.py:                    self.data_dict["total_heating_per_source_eV"] = tot_eV
./reactor_core/reactor.py:                    self.data_dict["total_heating_per_source_J"] = totJ
./reactor_core/reactor.py:                except Exception:
./reactor_core/reactor.py:                    totJ = None
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # 2) Compute scale if POWER_TARGET_W is set
./reactor_core/reactor.py:        if getattr(self, "POWER_TARGET_W", None) is not None:
./reactor_core/reactor.py:            if totJ is None or totJ == 0.0:
./reactor_core/reactor.py:                raise RuntimeError("Cannot compute scaling: no total heating per source available to normalize against POWER_TARGET_W.")
./reactor_core/reactor.py:            scale = float(self.POWER_TARGET_W) / float(totJ)  # units: W per (J per source) => 1/s (i.e., sources/sec)
./reactor_core/reactor.py:            self.data_dict["scale_JperSource_to_W"] = scale
./reactor_core/reactor.py:            self.data_dict["power_target_W"] = float(self.POWER_TARGET_W)
./reactor_core/reactor.py:            # compute total_power_W (sanity)
./reactor_core/reactor.py:            self.data_dict["total_power_W"] = float(totJ * scale)
./reactor_core/reactor.py:            print(f"[INFO] Computed scale: scale_JperSource_to_W = {scale:.6e} (sources/sec equivalent)")
./reactor_core/reactor.py:            print(f"[INFO] total_heating_per_source_J = {totJ:.6e}; scaled total_power_W = {self.data_dict['total_power_W']:.6e} (should equal POWER_TARGET_W)")
./reactor_core/reactor.py:        else:
./reactor_core/reactor.py:            # no power target provided: just record that no scale applied
./reactor_core/reactor.py:            self.data_dict.setdefault("scale_JperSource_to_W", None)
./reactor_core/reactor.py:            print("[INFO] POWER_TARGET_W not set; skipping automatic scaling. You can set it with set_power_target(W).")
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # 3) Apply scaling to mesh_heating and mesh_flux if available
./reactor_core/reactor.py:        scale = self.data_dict.get("scale_JperSource_to_W", None)
./reactor_core/reactor.py:        if scale is not None:
./reactor_core/reactor.py:            # mesh_heating_mean_3d -> W per cell
./reactor_core/reactor.py:            if "mesh_heating_mean_3d" in self.data_dict and self.data_dict["mesh_heating_mean_3d"] is not None:
./reactor_core/reactor.py:                mh3 = np.asarray(self.data_dict["mesh_heating_mean_3d"], dtype=float)
./reactor_core/reactor.py:                self.data_dict["mesh_heating_W_3d"] = mh3 * scale
./reactor_core/reactor.py:                if "mesh_heating_std_3d" in self.data_dict and self.data_dict["mesh_heating_std_3d"] is not None:
./reactor_core/reactor.py:                    self.data_dict["mesh_heating_W_std_3d"] = np.asarray(self.data_dict["mesh_heating_std_3d"], dtype=float) * scale
./reactor_core/reactor.py:                # recompute peaking factor in physical units
./reactor_core/reactor.py:                avg = float(self.data_dict["mesh_heating_W_3d"].mean())
./reactor_core/reactor.py:                peak = float(self.data_dict["mesh_heating_W_3d"].max())
./reactor_core/reactor.py:                self.data_dict["mesh_heating_peaking_physical"] = (peak / avg) if avg != 0 else None
./reactor_core/reactor.py:                print(f"[INFO] mesh heating converted to W: peak={peak:.6e} W, avg={avg:.6e} W, peaking={self.data_dict['mesh_heating_peaking_physical']}")
./reactor_core/reactor.py:            # If you want to scale mesh_flux to e.g. neutrons/cm2/s, you need a neutrons-per-source rate (scale_neutrons_per_source),
./reactor_core/reactor.py:            # which is typically the same as 'scale' if heating was computed from fission energy; otherwise compute separately.
./reactor_core/reactor.py:            # For now we set flux scaling placeholder:
./reactor_core/reactor.py:            self.data_dict.setdefault("mesh_flux_scaling_factor", None)
./reactor_core/reactor.py:
./reactor_core/reactor.py:        return self.data_dict
./reactor_core/reactor.py:
./reactor_core/reactor.py:    # def postprocess_statepoint(self, sp_file):
./reactor_core/reactor.py:    #     print(f"[POST] Reading statepoint file: {sp_file}")
./reactor_core/reactor.py:    #     sp = openmc.StatePoint(sp_file)
./reactor_core/reactor.py:    #
./reactor_core/reactor.py:    #     # k_eff
./reactor_core/reactor.py:    #     try:
./reactor_core/reactor.py:    #         k_res = sp.k_combined
./reactor_core/reactor.py:    #         try:
./reactor_core/reactor.py:    #             k_val = k_res.nominal_value
./reactor_core/reactor.py:    #             k_std = k_res.std_dev
./reactor_core/reactor.py:    #         except Exception:
./reactor_core/reactor.py:    #             k_val = float(k_res)
./reactor_core/reactor.py:    #             k_std = None
./reactor_core/reactor.py:    #     except Exception:
./reactor_core/reactor.py:    #         try:
./reactor_core/reactor.py:    #             k_val = float(sp.k_combined[0].n)
./reactor_core/reactor.py:    #             k_std = float(sp.k_combined[0].s)
./reactor_core/reactor.py:    #         except Exception:
./reactor_core/reactor.py:    #             k_val = None
./reactor_core/reactor.py:    #             k_std = None
./reactor_core/reactor.py:    #     print(f"  k_eff = {k_val}  (std dev = {k_std})")
./reactor_core/reactor.py:    #     self.data_dict["k_val"] = k_val
./reactor_core/reactor.py:    #     self.data_dict["k_std"] = k_std
./reactor_core/reactor.py:    #
./reactor_core/reactor.py:    #     # Find tally by name robustly
./reactor_core/reactor.py:    #     def find_tally_by_name(name):
./reactor_core/reactor.py:    #         for t_id, t in sp.tallies.items():
./reactor_core/reactor.py:    #             try:
./reactor_core/reactor.py:    #                 if getattr(t, "name", None) == name:
./reactor_core/reactor.py:    #                     return t
./reactor_core/reactor.py:    #             except Exception:
./reactor_core/reactor.py:    #                 pass
./reactor_core/reactor.py:    #         return None
./reactor_core/reactor.py:    #
./reactor_core/reactor.py:    #     t_nuclide = find_tally_by_name("nuclide_rates")
./reactor_core/reactor.py:    #     if t_nuclide is not None:
./reactor_core/reactor.py:    #         # parse mean/std shapes intelligently
./reactor_core/reactor.py:    #         mean = t_nuclide.mean
./reactor_core/reactor.py:    #         std = t_nuclide.std_dev
./reactor_core/reactor.py:    #         # attempt to infer shapes (common: (n_filters, n_scores, n_nuclides))
./reactor_core/reactor.py:    #         arr_mean = mean
./reactor_core/reactor.py:    #         arr_std = std
./reactor_core/reactor.py:    #         # flatten to 1D if needed, then reshape if possible
./reactor_core/reactor.py:    #         flat_mean = arr_mean.flatten()
./reactor_core/reactor.py:    #         flat_std = arr_std.flatten()
./reactor_core/reactor.py:    #         # try to detect counts from metadata
./reactor_core/reactor.py:    #         scores = t_nuclide.scores
./reactor_core/reactor.py:    #         nuclides = [
./reactor_core/reactor.py:    #             n.decode() if isinstance(n, bytes) else n for n in t_nuclide.nuclides
./reactor_core/reactor.py:    #         ]
./reactor_core/reactor.py:    #         # attempt reshape
./reactor_core/reactor.py:    #         try:
./reactor_core/reactor.py:    #             arr_mean2 = flat_mean.reshape((-1, len(scores), len(nuclides)))
./reactor_core/reactor.py:    #             arr_std2 = flat_std.reshape((-1, len(scores), len(nuclides)))
./reactor_core/reactor.py:    #             # take first filter index (most common case)
./reactor_core/reactor.py:    #             data_mean = arr_mean2[0]
./reactor_core/reactor.py:    #             data_std = arr_std2[0]
./reactor_core/reactor.py:    #             fission_mean = data_mean[scores.index("fission"), :]
./reactor_core/reactor.py:    #             abs_mean = data_mean[scores.index("absorption"), :]
./reactor_core/reactor.py:    #             fission_std = data_std[scores.index("fission"), :]
./reactor_core/reactor.py:    #             abs_std = data_std[scores.index("absorption"), :]
./reactor_core/reactor.py:    #             self.data_dict["fission_std"] = fission_std
./reactor_core/reactor.py:    #             self.data_dict["fission_mean"] = fission_mean
./reactor_core/reactor.py:    #             self.data_dict["abs_std"] = abs_std
./reactor_core/reactor.py:    #             self.data_dict["abs_mean"] = abs_mean
./reactor_core/reactor.py:    #
./reactor_core/reactor.py:    #             # compute capture = absorption - fission
./reactor_core/reactor.py:    #             import numpy as np
./reactor_core/reactor.py:    #
./reactor_core/reactor.py:    #             capture_mean = abs_mean - fission_mean
./reactor_core/reactor.py:    #             capture_std = (abs_std**2 + fission_std**2) ** 0.5
./reactor_core/reactor.py:    #
./reactor_core/reactor.py:    #             self.data_dict["capture_mean"] = capture_mean
./reactor_core/reactor.py:    #             self.data_dict["capture_std"] = capture_std
./reactor_core/reactor.py:    #             print("  Nuclide reaction rates (per-nuclide) [mean ± std]:")
./reactor_core/reactor.py:    #             for i, nuc in enumerate(nuclides):
./reactor_core/reactor.py:    #                 print(
./reactor_core/reactor.py:    #                     f"    {nuc}: fission = {fission_mean[i]:.6e} ± {fission_std[i]:.2e}"
./reactor_core/reactor.py:    #                 )
./reactor_core/reactor.py:    #                 print(
./reactor_core/reactor.py:    #                     f"           absorption = {abs_mean[i]:.6e} ± {abs_std[i]:.2e}"
./reactor_core/reactor.py:    #                 )
./reactor_core/reactor.py:    #                 print(
./reactor_core/reactor.py:    #                     f"           capture = {capture_mean[i]:.6e} ± {capture_std[i]:.2e}"
./reactor_core/reactor.py:    #                 )
./reactor_core/reactor.py:    #         except Exception as e:
./reactor_core/reactor.py:    #             print(
./reactor_core/reactor.py:    #                 "[WARN] Could not reshape nuclide_rates tally to expected dims:", e
./reactor_core/reactor.py:    #             )
./reactor_core/reactor.py:    #     else:
./reactor_core/reactor.py:    #         print("  Tally 'nuclide_rates' not found in statepoint.")
./reactor_core/reactor.py:    #
./reactor_core/reactor.py:    #     # mesh flux & heating example (print a few values)
./reactor_core/reactor.py:    #     t_mesh_flux = find_tally_by_name("mesh_flux")
./reactor_core/reactor.py:    #     if t_mesh_flux:
./reactor_core/reactor.py:    #         mf = t_mesh_flux.mean.flatten()
./reactor_core/reactor.py:    #         ms = t_mesh_flux.std_dev.flatten()
./reactor_core/reactor.py:    #         self.data_dict["mf"] = mf
./reactor_core/reactor.py:    #         self.data_dict["ms"] = ms
./reactor_core/reactor.py:    #         nprint = min(8, mf.size)
./reactor_core/reactor.py:    #         print(f"  mesh_flux: first {nprint} cells mean:", mf[:nprint])
./reactor_core/reactor.py:    #         print(f"             first {nprint} cells std :", ms[:nprint])
./reactor_core/reactor.py:    #     else:
./reactor_core/reactor.py:    #         print("  mesh_flux tally missing.")
./reactor_core/reactor.py:    #
./reactor_core/reactor.py:    #     t_heating = find_tally_by_name("heating")
./reactor_core/reactor.py:    #     if t_heating:
./reactor_core/reactor.py:    #         hm = t_heating.mean.flatten()
./reactor_core/reactor.py:    #         hs = t_heating.std_dev.flatten()
./reactor_core/reactor.py:    #         self.data_dict["hm"] = hm
./reactor_core/reactor.py:    #         self.data_dict["hs"] = hs
./reactor_core/reactor.py:    #         print(f"  heating (cell): mean {hm}, std {hs}")
./reactor_core/reactor.py:    #     else:
./reactor_core/reactor.py:    #         print("  heating tally missing.")
./reactor_core/reactor.py:    #
./reactor_core/reactor.py:    #     t_curr = find_tally_by_name("surface_current")
./reactor_core/reactor.py:    #     if t_curr:
./reactor_core/reactor.py:    #         cm = t_curr.mean.flatten()
./reactor_core/reactor.py:    #         self.data_dict["cm"] = cm
./reactor_core/reactor.py:    #         print("  surface_current (leakage) first values:", cm[: min(6, cm.size)])
./reactor_core/reactor.py:    #     else:
./reactor_core/reactor.py:    #         print("  surface_current tally missing.")
./reactor_core/reactor.py:    #
./reactor_core/reactor.py:    #     # energy spectrum
./reactor_core/reactor.py:    #     t_spec = find_tally_by_name("spectrum")
./reactor_core/reactor.py:    #     if t_spec:
./reactor_core/reactor.py:    #         tm = t_spec.mean.flatten()
./reactor_core/reactor.py:    #         self.data_dict["tm"] = tm
./reactor_core/reactor.py:    #         print("  spectrum (energy bins) means:", tm)
./reactor_core/reactor.py:    #     else:
./reactor_core/reactor.py:    #         print("  spectrum tally missing.")
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def get_data(self):
./reactor_core/reactor.py:        return self.data_dict
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def load_data(self):
./reactor_core/reactor.py:        try:
./reactor_core/reactor.py:            openmc.reset_auto_ids()
./reactor_core/reactor.py:        except Exception:
./reactor_core/reactor.py:            # older OpenMC might not have this; ignore if unavailable
./reactor_core/reactor.py:            pass
./reactor_core/reactor.py:
./reactor_core/reactor.py:        fuel, water, mats = self.build_materials()
./reactor_core/reactor.py:        geom, fuel_cell, moderator_cell, fuel_cyl, outer_sphere = self.build_geometry(
./reactor_core/reactor.py:            fuel, water
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:        settings = self.build_settings()
./reactor_core/reactor.py:        tallies = self.build_tallies(fuel_cell, outer_sphere)
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # export & check geometry
./reactor_core/reactor.py:        geom.export_to_xml()
./reactor_core/reactor.py:        print("[INFO] Running geometry overlap check...")
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # optional plot for debugging
./reactor_core/reactor.py:        if self.DEBUG:
./reactor_core/reactor.py:            self.try_plot_geometry(geom)
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def run(self, sp=None):
./reactor_core/reactor.py:        # run OpenMC safely
./reactor_core/reactor.py:        try:
./reactor_core/reactor.py:            self.run_openmc_safe(run_depletion=self.RUN_DEPLETION, depletion_days=0.0, sp=sp)
./reactor_core/reactor.py:        except Exception as e:
./reactor_core/reactor.py:            print("[FATAL] OpenMC failed. See messages above for diagnosis.")
./reactor_core/reactor.py:            # exit non-zero so caller sees failure
./reactor_core/reactor.py:            sys.exit(2)
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def get_postprocess_data(self):
./reactor_core/reactor.py:        # postprocess latest statepoint
./reactor_core/reactor.py:        sp = self.latest_statepoint()[0]
./reactor_core/reactor.py:        if sp:
./reactor_core/reactor.py:            self.postprocess_all_tallies(sp)
./reactor_core/reactor.py:        else:
./reactor_core/reactor.py:            print(
./reactor_core/reactor.py:                "[ERROR] No statepoint file found after run. OpenMC may have failed before writing output."
./reactor_core/reactor.py:            )
./reactor_core/reactor.py:
./reactor_core/reactor.py:        print("[DONE] Script finished.")
./reactor_core/reactor.py:        return self.data_dict
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def add_detector_tallies(
./reactor_core/reactor.py:        self,
./reactor_core/reactor.py:        geom,
./reactor_core/reactor.py:        fuel_cell,
./reactor_core/reactor.py:        outer_sphere,
./reactor_core/reactor.py:        detector_positions=None,
./reactor_core/reactor.py:        detector_radius=2.0,
./reactor_core/reactor.py:    ):
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        Add small sphere/cell tallies that emulate in-core or ex-core detectors.
./reactor_core/reactor.py:        - detector_positions: list of (x,y,z) tuples where to place detectors.
./reactor_core/reactor.py:          Defaults: 4 positions outside the fuel at +/- X and +/- Y just outside fuel cylinder.
./reactor_core/reactor.py:        - detector_radius: radius of small detector sphere (cm)
./reactor_core/reactor.py:        This function writes new tally definitions to tallies.xml (appending to previous tallies).
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        # Use current materials as "void" detector filled with the moderator material (or vacuum)
./reactor_core/reactor.py:        # We'll create small volumes in the moderator region (or just outside outer_sphere for ex-core)
./reactor_core/reactor.py:        if detector_positions is None:
./reactor_core/reactor.py:            # place 4 detectors on +x,-x,+y,-y outside the fuel radius at r = fuel_radius + margin
./reactor_core/reactor.py:            margin = 5.0
./reactor_core/reactor.py:            r = self.FUEL_RADIUS + margin
./reactor_core/reactor.py:            detector_positions = [
./reactor_core/reactor.py:                (r, 0.0, 0.0),
./reactor_core/reactor.py:                (-r, 0.0, 0.0),
./reactor_core/reactor.py:                (0.0, r, 0.0),
./reactor_core/reactor.py:                (0.0, -r, 0.0),
./reactor_core/reactor.py:            ]
./reactor_core/reactor.py:
./reactor_core/reactor.py:        tallies = openmc.Tallies()
./reactor_core/reactor.py:
./reactor_core/reactor.py:        detectors = []
./reactor_core/reactor.py:        for i, pos in enumerate(detector_positions):
./reactor_core/reactor.py:            name = f"detector_{i}"
./reactor_core/reactor.py:            # small sphere surface
./reactor_core/reactor.py:            s = openmc.Sphere(r=detector_radius, x0=pos[0], y0=pos[1], z0=pos[2])
./reactor_core/reactor.py:            # create a detector material: thin fill with moderator composition (non-absorbing)
./reactor_core/reactor.py:            det_mat = openmc.Material(name=f"det_mat_{i}")
./reactor_core/reactor.py:            # Use light water composition as placeholder (or create vacuum)
./reactor_core/reactor.py:            det_mat.add_element("H", 2.0)
./reactor_core/reactor.py:            det_mat.add_element("O", 1.0)
./reactor_core/reactor.py:            det_mat.set_density(
./reactor_core/reactor.py:                "g/cm3", 0.001
./reactor_core/reactor.py:            )  # tiny density to avoid absorbing too much
./reactor_core/reactor.py:            # Export material to unique file set by appending to existing mats later
./reactor_core/reactor.py:            detectors.append((name, s, det_mat))
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # Add detector materials and temporary geometry cells to a temp universe so tallies can reference them
./reactor_core/reactor.py:        # We'll create tallies referencing spherical volumes via CellFilter using temporary cells,
./reactor_core/reactor.py:        # but we won't overwrite the main geometry.xml here — instead the function will create tally xml that uses
./reactor_core/reactor.py:        # SurfaceFilters with surface definitions (OpenMC supports SurfaceFilter). Simpler: create mesh tallies around positions
./reactor_core/reactor.py:        # For portability, we will create small mesh volumes centered at detector positions using MeshFilters.
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # Create tallies for detector "voxels" using RegularMesh clipped to small region around detector pos
./reactor_core/reactor.py:        for i, (name, sph, det_mat) in enumerate(detectors):
./reactor_core/reactor.py:            # small mesh size box around pos
./reactor_core/reactor.py:            px, py, pz = detector_positions[i]
./reactor_core/reactor.py:            dx = detector_radius
./reactor_core/reactor.py:            mesh = openmc.RegularMesh()
./reactor_core/reactor.py:            # one-cell mesh covering small cube around detector
./reactor_core/reactor.py:            mesh.dimension = [1, 1, 1]
./reactor_core/reactor.py:            mesh.lower_left = [px - dx, py - dx, pz - dx]
./reactor_core/reactor.py:            mesh.upper_right = [px + dx, py + dx, pz + dx]
./reactor_core/reactor.py:            mesh_filter = openmc.MeshFilter(mesh)
./reactor_core/reactor.py:
./reactor_core/reactor.py:            t_det = openmc.Tally(name=name)
./reactor_core/reactor.py:            t_det.filters = [mesh_filter]
./reactor_core/reactor.py:            # Use 'flux' as detector measure (neutron flux proportional to count rate)
./reactor_core/reactor.py:            t_det.scores = ["flux"]
./reactor_core/reactor.py:            tallies.append(t_det)
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # Append these tallies to any existing tallies.xml by reading current tallies.xml and writing combined
./reactor_core/reactor.py:        # Easiest approach: export these to a temporary tally file and then merge with existing tallies.xml externally.
./reactor_core/reactor.py:        tallies.export_to_xml()  # writes tallies.xml (overwrites existing)
./reactor_core/reactor.py:        print(
./reactor_core/reactor.py:            "[INFO] Detector tallies added exported to tallies.xml (be careful: this overwrites previous tallies.xml)."
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:        print(
./reactor_core/reactor.py:            "       If you want to preserve original tallies, copy them before calling this function."
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # NOTE: If you want to preserve previous tallies, modify this function to read existing tallies.xml and append.
./reactor_core/reactor.py:        # For now we keep it simple. You can re-call build_tallies afterward to restore standard tallies.
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def simulate_detectors_from_mesh(
./reactor_core/reactor.py:        self, sp_file, detector_positions, NX=None, NY=None, NZ=None, mesh_box=None
./reactor_core/reactor.py:    ):
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        Fast surrogate: compute detector responses from the mesh_flux tally by integrating over nearest mesh cell(s).
./reactor_core/reactor.py:        - sp_file: statepoint filename
./reactor_core/reactor.py:        - detector_positions: list of (x,y,z)
./reactor_core/reactor.py:        - NX/NY/NZ: mesh dims used in the run (if None, use self.NX etc)
./reactor_core/reactor.py:        - mesh_box: [-r,r] box extents (if None deduce from self.OUTER_RADIUS)
./reactor_core/reactor.py:        Returns: list of detector estimates (flux per detector) and optional uncertainties
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        sp = openmc.StatePoint(sp_file)
./reactor_core/reactor.py:        if NX is None:
./reactor_core/reactor.py:            NX = self.NX
./reactor_core/reactor.py:        if NY is None:
./reactor_core/reactor.py:            NY = self.NY
./reactor_core/reactor.py:        if NZ is None:
./reactor_core/reactor.py:            NZ = self.NZ
./reactor_core/reactor.py:        if mesh_box is None:
./reactor_core/reactor.py:            r = self.OUTER_RADIUS
./reactor_core/reactor.py:            mesh_box = [-r + self.MESH_MARGIN, r - self.MESH_MARGIN]
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # find mesh_flux tally
./reactor_core/reactor.py:        t_mesh = None
./reactor_core/reactor.py:        for tid, t in sp.tallies.items():
./reactor_core/reactor.py:            if getattr(t, "name", "") == "mesh_flux":
./reactor_core/reactor.py:                t_mesh = t
./reactor_core/reactor.py:                break
./reactor_core/reactor.py:        if t_mesh is None:
./reactor_core/reactor.py:            raise RuntimeError(
./reactor_core/reactor.py:                "mesh_flux tally not found in statepoint; cannot simulate detectors from mesh"
./reactor_core/reactor.py:            )
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # flatten means and stds
./reactor_core/reactor.py:        mean = t_mesh.mean.flatten()
./reactor_core/reactor.py:        std = t_mesh.std_dev.flatten()
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # reshape to (NX,NY,NZ) with caveats: if multiple score dims exist this may need adjusting
./reactor_core/reactor.py:        total_cells = NX * NY * NZ
./reactor_core/reactor.py:        if mean.size < total_cells:
./reactor_core/reactor.py:            raise RuntimeError(
./reactor_core/reactor.py:                f"mesh_flux size ({mean.size}) smaller than NX*NY*NZ ({total_cells})"
./reactor_core/reactor.py:            )
./reactor_core/reactor.py:        vals = mean[:total_cells].reshape((NX, NY, NZ))
./reactor_core/reactor.py:        errs = std[:total_cells].reshape((NX, NY, NZ))
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # compute coordinates for cell centers
./reactor_core/reactor.py:        low = mesh_box[0]
./reactor_core/reactor.py:        high = mesh_box[1]
./reactor_core/reactor.py:        xs = np.linspace(low, high, NX, endpoint=False) + (high - low) / NX / 2.0
./reactor_core/reactor.py:        ys = np.linspace(low, high, NY, endpoint=False) + (high - low) / NY / 2.0
./reactor_core/reactor.py:        zs = np.linspace(low, high, NZ, endpoint=False) + (high - low) / NZ / 2.0
./reactor_core/reactor.py:
./reactor_core/reactor.py:        det_vals = []
./reactor_core/reactor.py:        det_errs = []
./reactor_core/reactor.py:        for px, py, pz in detector_positions:
./reactor_core/reactor.py:            # find nearest cell index
./reactor_core/reactor.py:            ix = int(np.clip(np.searchsorted(xs, px), 0, NX - 1))
./reactor_core/reactor.py:            iy = int(np.clip(np.searchsorted(ys, py), 0, NY - 1))
./reactor_core/reactor.py:            iz = int(np.clip(np.searchsorted(zs, pz), 0, NZ - 1))
./reactor_core/reactor.py:            det_vals.append(float(vals[ix, iy, iz]))
./reactor_core/reactor.py:            det_errs.append(float(errs[ix, iy, iz]))
./reactor_core/reactor.py:        return det_vals, det_errs
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def try_depletion_step(self, dt_days=1.0 / 24.0):
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        Attempt a single depletion step using openmc.deplete.CoupledOperator.
./reactor_core/reactor.py:        This will run both transport & depletion and write depletion file.
./reactor_core/reactor.py:        If depletion is unavailable or fails, function returns False.
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        try:
./reactor_core/reactor.py:            from openmc.deplete import CoupledOperator, Integrator
./reactor_core/reactor.py:
./reactor_core/reactor.py:            print("[INFO] Running a single depletion step (this may be slow)...")
./reactor_core/reactor.py:            op = CoupledOperator()
./reactor_core/reactor.py:            integrator = Integrator(op, [dt_days])
./reactor_core/reactor.py:            integrator.integrate()
./reactor_core/reactor.py:            print(
./reactor_core/reactor.py:                "[INFO] Depletion step completed and depletion_results.h5 written (or similar)."
./reactor_core/reactor.py:            )
./reactor_core/reactor.py:            return True
./reactor_core/reactor.py:        except Exception as e:
./reactor_core/reactor.py:            print("[WARN] openmc.deplete unavailable or failed:", e)
./reactor_core/reactor.py:            return False
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def perturbation_sweep_boron(
./reactor_core/reactor.py:        self, ppm_list, power_target_W=None, run_depletion=False
./reactor_core/reactor.py:    ):
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        Sweep soluble boron by modifying the water material and re-running OpenMC for each ppm in ppm_list.
./reactor_core/reactor.py:        Returns list of (ppm, k_eff, k_std).
./reactor_core/reactor.py:        NOTE: conversion of ppm->atomic fraction used here is approximate. For accurate modeling convert to exact
./reactor_core/reactor.py:        number densities using molar masses and Avogadro's number.
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        results = []
./reactor_core/reactor.py:        # backup original materials.xml
./reactor_core/reactor.py:        shutil.copy("materials.xml", "materials.xml.bak")
./reactor_core/reactor.py:        for ppm in ppm_list:
./reactor_core/reactor.py:            print(f"[SWEEP-BORON] Running for {ppm} ppm (approx)...")
./reactor_core/reactor.py:            # re-create materials with boron approximate addition
./reactor_core/reactor.py:            fuel, water, mats = self.build_materials()
./reactor_core/reactor.py:            # create new water with boron mass fraction approx
./reactor_core/reactor.py:            new_water = openmc.Material(name="Light water with B")
./reactor_core/reactor.py:            new_water.set_density("g/cm3", 0.743)
./reactor_core/reactor.py:            new_water.add_element("H", 2.0)
./reactor_core/reactor.py:            new_water.add_element("O", 1.0)
./reactor_core/reactor.py:            # approximate add boron by atomic fraction (very rough)
./reactor_core/reactor.py:            b_frac = ppm * 1e-6
./reactor_core/reactor.py:            try:
./reactor_core/reactor.py:                new_water.add_element("B", b_frac)
./reactor_core/reactor.py:            except Exception:
./reactor_core/reactor.py:                # fallback: tiny B10 nuclide
./reactor_core/reactor.py:                new_water.add_nuclide("B10", 1e-8)
./reactor_core/reactor.py:            mats = openmc.Materials([fuel, new_water])
./reactor_core/reactor.py:            mats.export_to_xml()
./reactor_core/reactor.py:            # re-export geometry (unchanged)
./reactor_core/reactor.py:            _, _, _, _, _ = self.build_geometry(fuel, new_water)
./reactor_core/reactor.py:            # re-export tallies & settings
./reactor_core/reactor.py:            self.build_tallies(
./reactor_core/reactor.py:                fuel, outer_sphere=openmc.Sphere(r=self.OUTER_RADIUS)
./reactor_core/reactor.py:            )  # quick replacement
./reactor_core/reactor.py:            self.build_settings()
./reactor_core/reactor.py:            # run transport
./reactor_core/reactor.py:            self.run_openmc_safe(run_depletion=run_depletion)
./reactor_core/reactor.py:            sp = self.latest_statepoint()[0]
./reactor_core/reactor.py:            if sp:
./reactor_core/reactor.py:                sp_obj = openmc.StatePoint(sp)
./reactor_core/reactor.py:                try:
./reactor_core/reactor.py:                    k_res = sp_obj.k_combined
./reactor_core/reactor.py:                    try:
./reactor_core/reactor.py:                        kv = k_res.nominal_value
./reactor_core/reactor.py:                        ks = k_res.std_dev
./reactor_core/reactor.py:                    except Exception:
./reactor_core/reactor.py:                        kv = float(k_res)
./reactor_core/reactor.py:                        ks = None
./reactor_core/reactor.py:                except Exception:
./reactor_core/reactor.py:                    kv = None
./reactor_core/reactor.py:                    ks = None
./reactor_core/reactor.py:            else:
./reactor_core/reactor.py:                kv, ks = None, None
./reactor_core/reactor.py:            results.append((ppm, kv, ks))
./reactor_core/reactor.py:        # restore original materials
./reactor_core/reactor.py:        if os.path.exists("materials.xml.bak"):
./reactor_core/reactor.py:            shutil.move("materials.xml.bak", "materials.xml")
./reactor_core/reactor.py:        # re-export original mats and geometry
./reactor_core/reactor.py:        self.build_materials()
./reactor_core/reactor.py:        self.build_geometry(*self.build_materials()[:2])
./reactor_core/reactor.py:        return results
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def perturbation_sweep_rod(
./reactor_core/reactor.py:        self, insertion_positions_cm, absorber_nuc="Gd157", run_depletion=False
./reactor_core/reactor.py:    ):
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        Sweep a simple absorber rod insertion depth (demo). For realistic cores, provide a rod-parameterized geometry.
./reactor_core/reactor.py:        Returns list of (insertion_cm, k_eff, k_std).
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        results = []
./reactor_core/reactor.py:        # backup geometry xml
./reactor_core/reactor.py:        shutil.copy("geometry.xml", "geometry.xml.bak")
./reactor_core/reactor.py:        for ins in insertion_positions_cm:
./reactor_core/reactor.py:            print(f"[SWEEP-ROD] insertion={ins} cm ...")
./reactor_core/reactor.py:            # create absorber material
./reactor_core/reactor.py:            absorber = openmc.Material(name="absorber_mat")
./reactor_core/reactor.py:            try:
./reactor_core/reactor.py:                absorber.add_nuclide(absorber_nuc, 1.0)
./reactor_core/reactor.py:            except Exception:
./reactor_core/reactor.py:                absorber.add_nuclide("Gd157", 1.0)
./reactor_core/reactor.py:            absorber.set_density("g/cm3", 8.0)
./reactor_core/reactor.py:            mats = openmc.Materials([absorber])
./reactor_core/reactor.py:            mats.export_to_xml()
./reactor_core/reactor.py:            # rebuild geometry with absorber inserted (demo: coaxial absorber in fuel)
./reactor_core/reactor.py:            # This is a simplified approach; adapt for real rod lattice
./reactor_core/reactor.py:            fuel, water, _ = self.build_materials()
./reactor_core/reactor.py:            fuel_cell = openmc.Cell(name="fuel")
./reactor_core/reactor.py:            fuel_cell.fill = fuel
./reactor_core/reactor.py:            fuel_cell.region = -openmc.ZCylinder(r=self.FUEL_RADIUS) & -openmc.Sphere(
./reactor_core/reactor.py:                r=self.OUTER_RADIUS
./reactor_core/reactor.py:            )
./reactor_core/reactor.py:            # absorber cylinder with z-limited insertion
./reactor_core/reactor.py:            abs_cyl = openmc.ZCylinder(r=self.FUEL_RADIUS / 2.0)
./reactor_core/reactor.py:            plane_min = openmc.ZPlane(z0=-ins / 2.0)
./reactor_core/reactor.py:            plane_max = openmc.ZPlane(z0=ins / 2.0)
./reactor_core/reactor.py:            absorber_cell = openmc.Cell(name="absorber")
./reactor_core/reactor.py:            absorber_cell.fill = absorber
./reactor_core/reactor.py:            absorber_cell.region = -abs_cyl & +plane_min & -plane_max
./reactor_core/reactor.py:            moderator_cell = openmc.Cell(name="moderator")
./reactor_core/reactor.py:            moderator_cell.fill = water
./reactor_core/reactor.py:            moderator_cell.region = +openmc.ZCylinder(
./reactor_core/reactor.py:                r=self.FUEL_RADIUS
./reactor_core/reactor.py:            ) & -openmc.Sphere(r=self.OUTER_RADIUS)
./reactor_core/reactor.py:
./reactor_core/reactor.py:            univ = openmc.Universe(cells=[fuel_cell, absorber_cell, moderator_cell])
./reactor_core/reactor.py:            geom = openmc.Geometry(univ)
./reactor_core/reactor.py:            geom.export_to_xml()
./reactor_core/reactor.py:            self.build_tallies(
./reactor_core/reactor.py:                fuel_cell, outer_sphere=openmc.Sphere(r=self.OUTER_RADIUS)
./reactor_core/reactor.py:            )
./reactor_core/reactor.py:            self.build_settings()
./reactor_core/reactor.py:            self.run_openmc_safe(run_depletion=run_depletion)
./reactor_core/reactor.py:            sp = self.latest_statepoint()[0]
./reactor_core/reactor.py:            if sp:
./reactor_core/reactor.py:                sp_obj = openmc.StatePoint(sp)
./reactor_core/reactor.py:                try:
./reactor_core/reactor.py:                    k_res = sp_obj.k_combined
./reactor_core/reactor.py:                    try:
./reactor_core/reactor.py:                        kv = k_res.nominal_value
./reactor_core/reactor.py:                        ks = k_res.std_dev
./reactor_core/reactor.py:                    except Exception:
./reactor_core/reactor.py:                        kv = float(k_res)
./reactor_core/reactor.py:                        ks = None
./reactor_core/reactor.py:                except Exception:
./reactor_core/reactor.py:                    kv = None
./reactor_core/reactor.py:                    ks = None
./reactor_core/reactor.py:            else:
./reactor_core/reactor.py:                kv, ks = None, None
./reactor_core/reactor.py:            results.append((ins, kv, ks))
./reactor_core/reactor.py:        # restore geometry
./reactor_core/reactor.py:        if os.path.exists("geometry.xml.bak"):
./reactor_core/reactor.py:            shutil.move("geometry.xml.bak", "geometry.xml")
./reactor_core/reactor.py:        self.build_geometry(*self.build_materials()[:2])
./reactor_core/reactor.py:        return results
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def perturbation_sweep_temperature(self, temps_K, run_depletion=False):
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        Sweep material temperatures (fuel & water) and record k_eff for each temp.
./reactor_core/reactor.py:        Requires ACE libraries for multiple temperatures or interpolation to work.
./reactor_core/reactor.py:        Returns list of (T_K, k_eff, k_std).
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        results = []
./reactor_core/reactor.py:        # backup materials
./reactor_core/reactor.py:        shutil.copy("materials.xml", "materials.xml.bak")
./reactor_core/reactor.py:        for T in temps_K:
./reactor_core/reactor.py:            print(f"[SWEEP-TEMP] Running for temperature {T} K ...")
./reactor_core/reactor.py:            # build materials with .temperature set
./reactor_core/reactor.py:            fuel = openmc.Material(name="UO2 fuel")
./reactor_core/reactor.py:            fuel.add_nuclide("U235", 0.04)
./reactor_core/reactor.py:            fuel.add_nuclide("U238", 0.96)
./reactor_core/reactor.py:            fuel.add_nuclide("O16", 2.0)
./reactor_core/reactor.py:            fuel.set_density("g/cm3", 10.5)
./reactor_core/reactor.py:            fuel.temperature = T
./reactor_core/reactor.py:
./reactor_core/reactor.py:            water = openmc.Material(name="Light water")
./reactor_core/reactor.py:            water.add_element("H", 2.0)
./reactor_core/reactor.py:            water.add_element("O", 1.0)
./reactor_core/reactor.py:            water.set_density("g/cm3", 0.743)
./reactor_core/reactor.py:            water.temperature = T
./reactor_core/reactor.py:            try:
./reactor_core/reactor.py:                water.add_s_alpha_beta("c_H_in_H2O")
./reactor_core/reactor.py:            except Exception:
./reactor_core/reactor.py:                pass
./reactor_core/reactor.py:
./reactor_core/reactor.py:            mats = openmc.Materials([fuel, water])
./reactor_core/reactor.py:            mats.export_to_xml()
./reactor_core/reactor.py:            # rebuild geometry/tallies/settings for this material set
./reactor_core/reactor.py:            geom, fuel_cell, moderator_cell, fuel_cyl, outer_sphere = (
./reactor_core/reactor.py:                self.build_geometry(fuel, water)
./reactor_core/reactor.py:            )
./reactor_core/reactor.py:            self.build_tallies(fuel_cell, outer_sphere)
./reactor_core/reactor.py:            self.build_settings()
./reactor_core/reactor.py:            self.run_openmc_safe(run_depletion=run_depletion)
./reactor_core/reactor.py:            sp = self.latest_statepoint()[0]
./reactor_core/reactor.py:            if sp:
./reactor_core/reactor.py:                sp_obj = openmc.StatePoint(sp)
./reactor_core/reactor.py:                try:
./reactor_core/reactor.py:                    k_res = sp_obj.k_combined
./reactor_core/reactor.py:                    try:
./reactor_core/reactor.py:                        kv = k_res.nominal_value
./reactor_core/reactor.py:                        ks = k_res.std_dev
./reactor_core/reactor.py:                    except Exception:
./reactor_core/reactor.py:                        kv = float(k_res)
./reactor_core/reactor.py:                        ks = None
./reactor_core/reactor.py:                except Exception:
./reactor_core/reactor.py:                    kv = None
./reactor_core/reactor.py:                    ks = None
./reactor_core/reactor.py:            else:
./reactor_core/reactor.py:                kv, ks = None, None
./reactor_core/reactor.py:            results.append((T, kv, ks))
./reactor_core/reactor.py:        # restore original materials
./reactor_core/reactor.py:        if os.path.exists("materials.xml.bak"):
./reactor_core/reactor.py:            shutil.move("materials.xml.bak", "materials.xml")
./reactor_core/reactor.py:        self.build_materials()
./reactor_core/reactor.py:        return results
./reactor_core/reactor.py:
./reactor_core/reactor.py:
./reactor_core/reactor.py:# ----------------- End of methods to add -----------------
./reactor_core/reactor.py:
./reactor_core/reactor.py:
./reactor_core/reactor.py:class Reactor_core:
./reactor_core/reactor.py:    def __init__(self):
./reactor_core/reactor.py:        with open(config_file_name(), "r") as file:
./reactor_core/reactor.py:            self.config = yaml.safe_load(file)
./reactor_core/reactor.py:
./reactor_core/reactor.py:        self.ctx = zmq.Context()
./reactor_core/reactor.py:        self.ctrl_endpoint = self.config["connections"]["ctrl"]["endpoint"]
./reactor_core/reactor.py:        self.tick_endpoint = self.config["connections"]["tick"]["endpoint"]
./reactor_core/reactor.py:        self.heartbeat_endpoint = self.config["connections"]["heartbeat"]["endpoint"]
./reactor_core/reactor.py:        self.telemetry_endpoint = self.config["connections"]["telemetry"]["endpoint"]
./reactor_core/reactor.py:
./reactor_core/reactor.py:        self.ctrl = self.ctx.socket(
./reactor_core/reactor.py:            getattr(zmq, self.config["connections"]["ctrl"]["type"])
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:        # self.ctrl.connect(self.ctrl_endpoint)
./reactor_core/reactor.py:        self.name = get_name()
./reactor_core/reactor.py:        self.ctrl.setsockopt_string(zmq.IDENTITY, self.name)
./reactor_core/reactor.py:
./reactor_core/reactor.py:        self.tick = self.ctx.socket(
./reactor_core/reactor.py:            getattr(zmq, self.config["connections"]["tick"]["type"])
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:        self.tick.setsockopt_string(zmq.SUBSCRIBE, "")
./reactor_core/reactor.py:
./reactor_core/reactor.py:        self.heartbeat = self.ctx.socket(
./reactor_core/reactor.py:            getattr(zmq, self.config["connections"]["heartbeat"]["type"])
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:        self.telemetry = self.ctx.socket(
./reactor_core/reactor.py:            getattr(zmq, self.config["connections"]["telemetry"]["type"])
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:
./reactor_core/reactor.py:        get_connection_object(self.ctrl, self.config["connections"]["ctrl"]["type"])(
./reactor_core/reactor.py:            self.ctrl_endpoint
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:        # Test data log file
./reactor_core/reactor.py:        self.test_data_log_file = "test_data_log_file.pkl"
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # sim variables
./reactor_core/reactor.py:        self.sim_time = float()
./reactor_core/reactor.py:        self.tick_index = float()
./reactor_core/reactor.py:        self.time_step = float()
./reactor_core/reactor.py:        self.time_scale = 1
./reactor_core/reactor.py:        self.running = True
./reactor_core/reactor.py:        self.paused = False
./reactor_core/reactor.py:        self.state = "off"
./reactor_core/reactor.py:
./reactor_core/reactor.py:        self.ctx = zmq.Context()
./reactor_core/reactor.py:        self.reactor_parm = self.config["parameters"]
./reactor_core/reactor.py:        self.tick_data = None
./reactor_core/reactor.py:        self.dt_master = 1.0
./reactor_core/reactor.py:        self.last_sim_time = None
./reactor_core/reactor.py:        self.dt_sub_step = 1.0
./reactor_core/reactor.py:        self.part_sim_model = ParticalSim()
./reactor_core/reactor.py:        self.particalSimRunnerThread = threading.Thread(target=self.particalSimRunner, daemon=True)
./reactor_core/reactor.py:        self.particalSimRunnerActive = False
./reactor_core/reactor.py:        # self.part_sim_model.load_data()
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # Parameters from the config...
./reactor_core/reactor.py:        self.params = self.config["parameters"]
./reactor_core/reactor.py:        self.total_control_rods = sum(
./reactor_core/reactor.py:            [bank["rods"] for bank in self.params["rod_insertion_depth"]["banks"]]
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:        self.control_rod_banks = self.params["rod_insertion_depth"]["banks"]
./reactor_core/reactor.py:        self.bppm_ref = self.params["boron_ppm"]["value"]
./reactor_core/reactor.py:
./reactor_core/reactor.py:        # Main values after calculation
./reactor_core/reactor.py:        self.rho_rods = 0.0
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def save(self,filename : str, data, type_=None):
./reactor_core/reactor.py:        filename_split = filename.split(".")
./reactor_core/reactor.py:        if len(filename_split) > 1 and not type_:
./reactor_core/reactor.py:            type_ = filename_split[-1]
./reactor_core/reactor.py:        elif len(filename_split) <= 1:
./reactor_core/reactor.py:            print("Invalid file name...")
./reactor_core/reactor.py:        else:...
./reactor_core/reactor.py:
./reactor_core/reactor.py:        if type_ == "txt":
./reactor_core/reactor.py:            with open(filename, "a") as file:
./reactor_core/reactor.py:                file.write(data)
./reactor_core/reactor.py:        elif type_ == "json":
./reactor_core/reactor.py:            with open(filename, "a") as file:
./reactor_core/reactor.py:                json.dump(data, file, indent=4)
./reactor_core/reactor.py:        elif type_ == "pkl":
./reactor_core/reactor.py:            with open(f"{filename_split[0]}-{self.part_sim_model.BATCHES}.{filename_split[-1]}" , "wb") as f:
./reactor_core/reactor.py:                pickle.dump(data, f, protocol=pickle.HIGHEST_PROTOCOL)
./reactor_core/reactor.py:            self.send_msg(f"Added the ParticalSim Batch Size - {self.part_sim_model.BATCHES} data to {self.test_data_log_file}")
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def establish_connections(self):
./reactor_core/reactor.py:        get_connection_object(self.tick, self.config["connections"]["tick"]["type"])(
./reactor_core/reactor.py:            self.tick_endpoint
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:        get_connection_object(
./reactor_core/reactor.py:            self.telemetry, self.config["connections"]["telemetry"]["type"]
./reactor_core/reactor.py:        )(self.telemetry_endpoint)
./reactor_core/reactor.py:        get_connection_object(
./reactor_core/reactor.py:            self.heartbeat, self.config["connections"]["heartbeat"]["type"]
./reactor_core/reactor.py:        )(self.heartbeat_endpoint)
./reactor_core/reactor.py:        self.tick_thread.start()
./reactor_core/reactor.py:        self.running = True
./reactor_core/reactor.py:        return "Tick, Telemetry and HeartBeat"
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def particalSimRunner(self):
./reactor_core/reactor.py:        self.part_sim_model.load_data()
./reactor_core/reactor.py:        while True:
./reactor_core/reactor.py:            statepoint = self.part_sim_model.latest_statepoint()
./reactor_core/reactor.py:            statepoint_file = statepoint[0]
./reactor_core/reactor.py:            statepoint_max_batch = statepoint[1]
./reactor_core/reactor.py:            if statepoint_file:
./reactor_core/reactor.py:                self.part_sim_model.updateBatchSize(10)
./reactor_core/reactor.py:                self.part_sim_model.build_settings()
./reactor_core/reactor.py:            self.send_msg(f"Started Partical Sim on Batch Size - {self.part_sim_model.BATCHES}")
./reactor_core/reactor.py:            time.sleep(2)
./reactor_core/reactor.py:            self.part_sim_model.run(sp=statepoint_file)
./reactor_core/reactor.py:            time.sleep(2)
./reactor_core/reactor.py:            part_sim_data = self.part_sim_model.get_postprocess_data()
./reactor_core/reactor.py:            self.save(self.test_data_log_file, part_sim_data)
./reactor_core/reactor.py:            self.send_msg(f"Completed Partical Sim on Batch Size - {self.part_sim_model.BATCHES}")
./reactor_core/reactor.py:            time.sleep(5)
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def reactor_core_loop(self):
./reactor_core/reactor.py:        times = self.dt_master / self.dt_sub_step
./reactor_core/reactor.py:        for _ in range(times):
./reactor_core/reactor.py:
./reactor_core/reactor.py:            # Sum of control rod reactivity calculation...
./reactor_core/reactor.py:            for b in self.control_rod_banks:
./reactor_core/reactor.py:                frac_inserted = b["depth"] / b["length"]
./reactor_core/reactor.py:                if frac_inserted < 0.0:
./reactor_core/reactor.py:                    frac_inserted = 0.0
./reactor_core/reactor.py:                elif frac_inserted > 1.0:
./reactor_core/reactor.py:                    frac_inserted = 1.0
./reactor_core/reactor.py:
./reactor_core/reactor.py:                wt = b.get("worth_table")
./reactor_core/reactor.py:                if wt is None:
./reactor_core/reactor.py:                    total_bank_worth = self.params["control_rod_worth"]["value"] * (
./reactor_core/reactor.py:                        b["rods"] / self.total_control_rods
./reactor_core/reactor.py:                    )
./reactor_core/reactor.py:                    W_at_x = total_bank_worth * frac_inserted
./reactor_core/reactor.py:                else:
./reactor_core/reactor.py:                    wt_x = wt["x"]
./reactor_core/reactor.py:                    wt_y = wt["y"]
./reactor_core/reactor.py:                    W_at_x = self.piecewise_linear_eval(wt_x, wt_y, frac_inserted)
./reactor_core/reactor.py:                self.rho_rods += W_at_x
./reactor_core/reactor.py:
./reactor_core/reactor.py:            # Boron Reactivity calculation (Boron concentration in the coolant)
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def piecewise_linear_eval(self, x_points, y_points, x):
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        Evaluate piecewise-linear function defined by (x_points, y_points) at x.
./reactor_core/reactor.py:        Assumes x_points sorted ascending and x in [x_points[0], x_points[-1]].
./reactor_core/reactor.py:        """
./reactor_core/reactor.py:        if x <= x_points[0]:
./reactor_core/reactor.py:            return y_points[0]
./reactor_core/reactor.py:        if x >= x_points[-1]:
./reactor_core/reactor.py:            return y_points[-1]
./reactor_core/reactor.py:        # find interval
./reactor_core/reactor.py:        for i in range(len(x_points) - 1):
./reactor_core/reactor.py:            x0, x1 = x_points[i], x_points[i + 1]
./reactor_core/reactor.py:            if x0 <= x <= x1:
./reactor_core/reactor.py:                y0, y1 = y_points[i], y_points[i + 1]
./reactor_core/reactor.py:                t = (x - x0) / (x1 - x0)
./reactor_core/reactor.py:                return y0 + t * (y1 - y0)
./reactor_core/reactor.py:        # fallback
./reactor_core/reactor.py:        return y_points[-1]
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def _rho_boron_linear(
./reactor_core/reactor.py:        self,
./reactor_core/reactor.py:    ): ...
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def rho_boron_dynamic(
./reactor_core/reactor.py:        self,
./reactor_core/reactor.py:    ): ...
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def start(self):
./reactor_core/reactor.py:        self.control_thread = threading.Thread(target=self._control_loop, daemon=True)
./reactor_core/reactor.py:        self.control_thread.start()
./reactor_core/reactor.py:        self.dealerListen_thread = threading.Thread(
./reactor_core/reactor.py:            target=self._dealerListener, daemon=True
./reactor_core/reactor.py:        )
./reactor_core/reactor.py:        self.dealerListen_thread.start()
./reactor_core/reactor.py:
./reactor_core/reactor.py:        self.tick_thread = threading.Thread(target=self._tick_loop, daemon=True)
./reactor_core/reactor.py:        while True:
./reactor_core/reactor.py:            time.sleep(1)
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def _tick_loop(self):
./reactor_core/reactor.py:        while self.running:
./reactor_core/reactor.py:            if not self.paused and self.time_scale > 0:
./reactor_core/reactor.py:                try:
./reactor_core/reactor.py:                    data = self.tick.recv_json(flags=zmq.NOBLOCK)
./reactor_core/reactor.py:                    self.tick_data = data
./reactor_core/reactor.py:                    if self.last_sim_time is None:
./reactor_core/reactor.py:                        self.dt_master = data["time_step"] * data.get("time_scale", 1.0)
./reactor_core/reactor.py:                    else:
./reactor_core/reactor.py:                        self.dt_master = data["sim_time"] - self.last_sim_time
./reactor_core/reactor.py:                    # real_sleep = self.time_step / max(self.time_scale, 1e-9)
./reactor_core/reactor.py:                    self.last_sim_time = data["sim_time"]
./reactor_core/reactor.py:                except zmq.Again:
./reactor_core/reactor.py:                    ...
./reactor_core/reactor.py:                time.sleep(0.2)
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def _control_loop(self):
./reactor_core/reactor.py:        self.send_msg("Okey", type_="check", data=random.randint(1, 1000))
./reactor_core/reactor.py:        self.running = True
./reactor_core/reactor.py:        while self.running:
./reactor_core/reactor.py:            time.sleep(2)
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def _dealerListener(self):
./reactor_core/reactor.py:        while True:
./reactor_core/reactor.py:            try:
./reactor_core/reactor.py:                identity, msg = self.ctrl.recv_multipart(flags=zmq.NOBLOCK)
./reactor_core/reactor.py:                if identity or msg:
./reactor_core/reactor.py:                    decoded_msg = json.loads(msg.decode())
./reactor_core/reactor.py:                    if (
./reactor_core/reactor.py:                        decoded_msg["type"] == "command"
./reactor_core/reactor.py:                        and decoded_msg["name"] == "control_system"
./reactor_core/reactor.py:                    ):
./reactor_core/reactor.py:                        self._executation(decoded_msg)
./reactor_core/reactor.py:            except zmq.Again:
./reactor_core/reactor.py:                pass
./reactor_core/reactor.py:            time.sleep(0.05)
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def _executation(self, msg):
./reactor_core/reactor.py:        cmd = msg["command"]
./reactor_core/reactor.py:        if cmd == "establish_connections":
./reactor_core/reactor.py:            cc = self.establish_connections()
./reactor_core/reactor.py:            self.send_msg(
./reactor_core/reactor.py:                f"Establish-ED Connections of {cc} at {self.name}", type_="status"
./reactor_core/reactor.py:            )
./reactor_core/reactor.py:        elif cmd == "start-partical-sim-thread":
./reactor_core/reactor.py:            print("hello")
./reactor_core/reactor.py:            if not self.particalSimRunnerActive:
./reactor_core/reactor.py:                self.send_msg("Starting Partical Sim Thread...")
./reactor_core/reactor.py:                self.particalSimRunnerThread.start()
./reactor_core/reactor.py:                self.particalSimRunnerActive = True
./reactor_core/reactor.py:                self.send_msg("Started Partical Sim Thread...")
./reactor_core/reactor.py:        else:
./reactor_core/reactor.py:            self.send_msg("Error", ok=False, error="unknown command")
./reactor_core/reactor.py:
./reactor_core/reactor.py:    def send_msg(self, msg, type_="status", **kwargs):
./reactor_core/reactor.py:        data = {
./reactor_core/reactor.py:            "type": type_,
./reactor_core/reactor.py:            "name": self.name,
./reactor_core/reactor.py:            "status": f"{'Running' if self.running else 'Not Running'}",
./reactor_core/reactor.py:            "msg": msg,
./reactor_core/reactor.py:            **kwargs,
./reactor_core/reactor.py:        }
./reactor_core/reactor.py:        self.ctrl.send_multipart([b"", json.dumps(data).encode()])
./reactor_core/reactor.py:
./reactor_core/reactor.py:
./reactor_core/reactor.py:if __name__ == "__main__":
./reactor_core/reactor.py:    try:
./reactor_core/reactor.py:        reactor = Reactor_core()
./reactor_core/reactor.py:        reactor.start()
./reactor_core/reactor.py:    except KeyboardInterrupt:
./reactor_core/reactor.py:        print("Keyboard Interrupt !!!")
./reactor_core/reactor.py:    except EOFError:
./reactor_core/reactor.py:        print("EOF Error !!!")
./condenser_cooling/condenser.py:import os
./condenser_cooling/condenser.py:import sys
./condenser_cooling/condenser.py:
./condenser_cooling/condenser.py:sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
./condenser_cooling/condenser.py:from lib.lib import *
./condenser_cooling/condenser.py:
./condenser_cooling/condenser.py:import time, json, threading
./condenser_cooling/condenser.py:import zmq
./condenser_cooling/condenser.py:import yaml
./condenser_cooling/condenser.py:import time
./condenser_cooling/condenser.py:import random
./condenser_cooling/condenser.py:
./condenser_cooling/condenser.py:
./condenser_cooling/condenser.py:class Condenser:
./condenser_cooling/condenser.py:    def __init__(
./condenser_cooling/condenser.py:        self,
./condenser_cooling/condenser.py:    ):
./condenser_cooling/condenser.py:        with open(config_file_name(), "r") as file:
./condenser_cooling/condenser.py:            self.config = yaml.safe_load(file)
./condenser_cooling/condenser.py:
./condenser_cooling/condenser.py:        # pprint(self.config)
./condenser_cooling/condenser.py:        self.ctx = zmq.Context()
./condenser_cooling/condenser.py:        self.ctrl_endpoint = self.config["connections"]["ctrl"]["endpoint"]
./condenser_cooling/condenser.py:        self.tick_endpoint = self.config["connections"]["tick"]["endpoint"]
./condenser_cooling/condenser.py:        self.heartbeat_endpoint = self.config["connections"]["heartbeat"]["endpoint"]
./condenser_cooling/condenser.py:        self.telemetry_endpoint = self.config["connections"]["telemetry"]["endpoint"]
./condenser_cooling/condenser.py:
./condenser_cooling/condenser.py:        self.ctrl = self.ctx.socket(
./condenser_cooling/condenser.py:            getattr(zmq, self.config["connections"]["ctrl"]["type"])
./condenser_cooling/condenser.py:        )
./condenser_cooling/condenser.py:        self.name = get_name()
./condenser_cooling/condenser.py:        self.ctrl.setsockopt_string(zmq.IDENTITY, self.name)
./condenser_cooling/condenser.py:
./condenser_cooling/condenser.py:        get_connection_object(self.ctrl, self.config["connections"]["ctrl"]["type"])(
./condenser_cooling/condenser.py:            self.ctrl_endpoint
./condenser_cooling/condenser.py:        )
./condenser_cooling/condenser.py:
./condenser_cooling/condenser.py:
./condenser_cooling/condenser.py:        self.tick = self.ctx.socket(
./condenser_cooling/condenser.py:            getattr(zmq, self.config["connections"]["tick"]["type"])
./condenser_cooling/condenser.py:        )
./condenser_cooling/condenser.py:        self.tick.setsockopt_string(zmq.SUBSCRIBE, "")
./condenser_cooling/condenser.py:
./condenser_cooling/condenser.py:        self.heartbeat = self.ctx.socket(
./condenser_cooling/condenser.py:            getattr(zmq, self.config["connections"]["heartbeat"]["type"])
./condenser_cooling/condenser.py:        )
./condenser_cooling/condenser.py:        self.telemetry = self.ctx.socket(
./condenser_cooling/condenser.py:            getattr(zmq, self.config["connections"]["telemetry"]["type"])
./condenser_cooling/condenser.py:        )
./condenser_cooling/condenser.py:        self.running = False
./condenser_cooling/condenser.py:
./condenser_cooling/condenser.py:    def establish_connections(self):
./condenser_cooling/condenser.py:        self.running = True
./condenser_cooling/condenser.py:        get_connection_object(self.tick, self.config["connections"]["tick"]["type"])(
./condenser_cooling/condenser.py:            self.tick_endpoint
./condenser_cooling/condenser.py:        )
./condenser_cooling/condenser.py:        get_connection_object(
./condenser_cooling/condenser.py:            self.telemetry, self.config["connections"]["telemetry"]["type"]
./condenser_cooling/condenser.py:        )(self.telemetry_endpoint)
./condenser_cooling/condenser.py:        get_connection_object(
./condenser_cooling/condenser.py:            self.heartbeat, self.config["connections"]["heartbeat"]["type"]
./condenser_cooling/condenser.py:        )(self.heartbeat_endpoint)
./condenser_cooling/condenser.py:        self.tick_thread.start()
./condenser_cooling/condenser.py:        return "Tick, Telemetry and HeartBeat"
./condenser_cooling/condenser.py:
./condenser_cooling/condenser.py:    def start(self):
./condenser_cooling/condenser.py:        self.control_thread = threading.Thread(target=self._control_loop, daemon=True)
./condenser_cooling/condenser.py:        self.control_thread.start()
./condenser_cooling/condenser.py:        self.dealerListen_thread = threading.Thread(
./condenser_cooling/condenser.py:            target=self._dealerListener, daemon=True
./condenser_cooling/condenser.py:        )
./condenser_cooling/condenser.py:        self.dealerListen_thread.start()
./condenser_cooling/condenser.py:        self.tick_thread = threading.Thread(target=self._tick_loop, daemon=True)
./condenser_cooling/condenser.py:
./condenser_cooling/condenser.py:        while True:
./condenser_cooling/condenser.py:            time.sleep(1)
./condenser_cooling/condenser.py:
./condenser_cooling/condenser.py:    def _tick_loop(self):
./condenser_cooling/condenser.py:        while self.running:
./condenser_cooling/condenser.py:            try:
./condenser_cooling/condenser.py:                data = self.tick.recv_json(flags=zmq.NOBLOCK)
./condenser_cooling/condenser.py:                # self.send_msg(data, type_="tick-check")
./condenser_cooling/condenser.py:                # real_sleep = self.time_step / max(self.time_scale, 1e-9)
./condenser_cooling/condenser.py:                time.sleep(1)
./condenser_cooling/condenser.py:            except zmq.Again:
./condenser_cooling/condenser.py:                time.sleep(0.05)  # poll for control commands while paused
./condenser_cooling/condenser.py:
./condenser_cooling/condenser.py:    def _control_loop(self):
./condenser_cooling/condenser.py:        self.send_msg("Okey", type_="check", data=random.randint(1, 1000))
./condenser_cooling/condenser.py:        self.running = True
./condenser_cooling/condenser.py:        while self.running:
./condenser_cooling/condenser.py:            time.sleep(2)
./condenser_cooling/condenser.py:
./condenser_cooling/condenser.py:    def _heartbeat_loop(self): ...
./condenser_cooling/condenser.py:
./condenser_cooling/condenser.py:    def _dealerListener(self):
./condenser_cooling/condenser.py:        while True:
./condenser_cooling/condenser.py:            try:
./condenser_cooling/condenser.py:                identity, msg = self.ctrl.recv_multipart(flags=zmq.NOBLOCK)
./condenser_cooling/condenser.py:                # self.send_msg("recived msg....")
./condenser_cooling/condenser.py:                if identity or msg:
./condenser_cooling/condenser.py:                    decoded_msg = json.loads(msg.decode())
./condenser_cooling/condenser.py:                    if (
./condenser_cooling/condenser.py:                        decoded_msg["type"] == "command"
./condenser_cooling/condenser.py:                        and decoded_msg["name"] == "control_system"
./condenser_cooling/condenser.py:                    ):
./condenser_cooling/condenser.py:                        self._executation(decoded_msg)
./condenser_cooling/condenser.py:            except zmq.Again:
./condenser_cooling/condenser.py:                pass
./condenser_cooling/condenser.py:            time.sleep(0.05)
./condenser_cooling/condenser.py:
./condenser_cooling/condenser.py:    def _executation(self, msg):
./condenser_cooling/condenser.py:        cmd = msg["command"]
./condenser_cooling/condenser.py:        if cmd == "establish_connections":
./condenser_cooling/condenser.py:            cc = self.establish_connections()
./condenser_cooling/condenser.py:            self.send_msg(
./condenser_cooling/condenser.py:                f"Establish-ED Connections of {cc} at {self.name}", type_="status"
./condenser_cooling/condenser.py:            )
./condenser_cooling/condenser.py:        else:
./condenser_cooling/condenser.py:            self.send_msg("Error", ok=False, error="unknown command")
./condenser_cooling/condenser.py:
./condenser_cooling/condenser.py:    def send_msg(self, msg, type_="status", **kwargs):
./condenser_cooling/condenser.py:        data = {
./condenser_cooling/condenser.py:            "type": type_,
./condenser_cooling/condenser.py:            "name": self.name,
./condenser_cooling/condenser.py:            "status": f"{'Running' if self.running else 'Not Running'}",
./condenser_cooling/condenser.py:            "msg": msg,
./condenser_cooling/condenser.py:            **kwargs,
./condenser_cooling/condenser.py:        }
./condenser_cooling/condenser.py:        self.ctrl.send_multipart([b"", json.dumps(data).encode()])
./condenser_cooling/condenser.py:
./condenser_cooling/condenser.py:
./condenser_cooling/condenser.py:if __name__ == "__main__":
./condenser_cooling/condenser.py:    try:
./condenser_cooling/condenser.py:        condenser = Condenser()
./condenser_cooling/condenser.py:        condenser.start()
./condenser_cooling/condenser.py:    except KeyboardInterrupt:
./condenser_cooling/condenser.py:        print("Keyboard Interrupt !!!")
./condenser_cooling/condenser.py:    except EOFError:
./condenser_cooling/condenser.py:        print("EOF Error !!!")
./condenser_cooling_water_source/condenser_cooling_water_source.py:import os
./condenser_cooling_water_source/condenser_cooling_water_source.py:import sys
./condenser_cooling_water_source/condenser_cooling_water_source.py:
./condenser_cooling_water_source/condenser_cooling_water_source.py:sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
./condenser_cooling_water_source/condenser_cooling_water_source.py:from lib.lib import *
./condenser_cooling_water_source/condenser_cooling_water_source.py:
./condenser_cooling_water_source/condenser_cooling_water_source.py:import time, json, threading, random, zmq, yaml
./condenser_cooling_water_source/condenser_cooling_water_source.py:
./condenser_cooling_water_source/condenser_cooling_water_source.py:
./condenser_cooling_water_source/condenser_cooling_water_source.py:class CondenserCoolingWaterSource:
./condenser_cooling_water_source/condenser_cooling_water_source.py:    def __init__(
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self,
./condenser_cooling_water_source/condenser_cooling_water_source.py:    ):
./condenser_cooling_water_source/condenser_cooling_water_source.py:        with open(config_file_name(), "r") as file:
./condenser_cooling_water_source/condenser_cooling_water_source.py:            self.config = yaml.safe_load(file)
./condenser_cooling_water_source/condenser_cooling_water_source.py:
./condenser_cooling_water_source/condenser_cooling_water_source.py:        # pprint(self.config)
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.ctx = zmq.Context()
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.ctrl_endpoint = self.config["connections"]["ctrl"]["endpoint"]
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.tick_endpoint = self.config["connections"]["tick"]["endpoint"]
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.heartbeat_endpoint = self.config["connections"]["heartbeat"]["endpoint"]
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.telemetry_endpoint = self.config["connections"]["telemetry"]["endpoint"]
./condenser_cooling_water_source/condenser_cooling_water_source.py:
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.ctrl = self.ctx.socket(
./condenser_cooling_water_source/condenser_cooling_water_source.py:            getattr(zmq, self.config["connections"]["ctrl"]["type"])
./condenser_cooling_water_source/condenser_cooling_water_source.py:        )
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.name = get_name()
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.ctrl.setsockopt_string(zmq.IDENTITY, self.name)
./condenser_cooling_water_source/condenser_cooling_water_source.py:        # self.ctrl.connect(self.ctrl_endpoint)
./condenser_cooling_water_source/condenser_cooling_water_source.py:
./condenser_cooling_water_source/condenser_cooling_water_source.py:        get_connection_object(self.ctrl, self.config["connections"]["ctrl"]["type"])(
./condenser_cooling_water_source/condenser_cooling_water_source.py:            self.ctrl_endpoint
./condenser_cooling_water_source/condenser_cooling_water_source.py:        )
./condenser_cooling_water_source/condenser_cooling_water_source.py:
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.tick = self.ctx.socket(
./condenser_cooling_water_source/condenser_cooling_water_source.py:            getattr(zmq, self.config["connections"]["tick"]["type"])
./condenser_cooling_water_source/condenser_cooling_water_source.py:        )
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.tick.setsockopt_string(zmq.SUBSCRIBE, "")
./condenser_cooling_water_source/condenser_cooling_water_source.py:
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.heartbeat = self.ctx.socket(
./condenser_cooling_water_source/condenser_cooling_water_source.py:            getattr(zmq, self.config["connections"]["heartbeat"]["type"])
./condenser_cooling_water_source/condenser_cooling_water_source.py:        )
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.telemetry = self.ctx.socket(
./condenser_cooling_water_source/condenser_cooling_water_source.py:            getattr(zmq, self.config["connections"]["telemetry"]["type"])
./condenser_cooling_water_source/condenser_cooling_water_source.py:        )
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.running = False
./condenser_cooling_water_source/condenser_cooling_water_source.py:
./condenser_cooling_water_source/condenser_cooling_water_source.py:    def establish_connections(self):
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.running = True
./condenser_cooling_water_source/condenser_cooling_water_source.py:        get_connection_object(self.tick, self.config["connections"]["tick"]["type"])(
./condenser_cooling_water_source/condenser_cooling_water_source.py:            self.tick_endpoint
./condenser_cooling_water_source/condenser_cooling_water_source.py:        )
./condenser_cooling_water_source/condenser_cooling_water_source.py:        get_connection_object(
./condenser_cooling_water_source/condenser_cooling_water_source.py:            self.telemetry, self.config["connections"]["telemetry"]["type"]
./condenser_cooling_water_source/condenser_cooling_water_source.py:        )(self.telemetry_endpoint)
./condenser_cooling_water_source/condenser_cooling_water_source.py:        get_connection_object(
./condenser_cooling_water_source/condenser_cooling_water_source.py:            self.heartbeat, self.config["connections"]["heartbeat"]["type"]
./condenser_cooling_water_source/condenser_cooling_water_source.py:        )(self.heartbeat_endpoint)
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.tick_thread.start()
./condenser_cooling_water_source/condenser_cooling_water_source.py:        return "Tick, Telemetry and Heartbeat"
./condenser_cooling_water_source/condenser_cooling_water_source.py:
./condenser_cooling_water_source/condenser_cooling_water_source.py:    def start(self):
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.control_thread = threading.Thread(target=self._control_loop, daemon=True)
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.control_thread.start()
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.dealerListen_thread = threading.Thread(
./condenser_cooling_water_source/condenser_cooling_water_source.py:            target=self._dealerListener, daemon=True
./condenser_cooling_water_source/condenser_cooling_water_source.py:        )
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.dealerListen_thread.start()
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.tick_thread = threading.Thread(target=self._tick_loop, daemon=True)
./condenser_cooling_water_source/condenser_cooling_water_source.py:
./condenser_cooling_water_source/condenser_cooling_water_source.py:        while True:
./condenser_cooling_water_source/condenser_cooling_water_source.py:            time.sleep(1)
./condenser_cooling_water_source/condenser_cooling_water_source.py:
./condenser_cooling_water_source/condenser_cooling_water_source.py:    def _tick_loop(self):
./condenser_cooling_water_source/condenser_cooling_water_source.py:        while self.running:
./condenser_cooling_water_source/condenser_cooling_water_source.py:            try:
./condenser_cooling_water_source/condenser_cooling_water_source.py:                data = self.tick.recv_json(flags=zmq.NOBLOCK)
./condenser_cooling_water_source/condenser_cooling_water_source.py:                # self.send_msg(data, type_="tick-check")
./condenser_cooling_water_source/condenser_cooling_water_source.py:                # real_sleep = self.time_step / max(self.time_scale, 1e-9)
./condenser_cooling_water_source/condenser_cooling_water_source.py:                time.sleep(1)
./condenser_cooling_water_source/condenser_cooling_water_source.py:            except zmq.Again:
./condenser_cooling_water_source/condenser_cooling_water_source.py:                time.sleep(0.05)  # poll for control commands while paused
./condenser_cooling_water_source/condenser_cooling_water_source.py:
./condenser_cooling_water_source/condenser_cooling_water_source.py:    def _control_loop(self):
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.send_msg("Okey", type_="check", data=random.randint(1, 1000))
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.running = True
./condenser_cooling_water_source/condenser_cooling_water_source.py:        while self.running:
./condenser_cooling_water_source/condenser_cooling_water_source.py:            time.sleep(2)
./condenser_cooling_water_source/condenser_cooling_water_source.py:
./condenser_cooling_water_source/condenser_cooling_water_source.py:    def _heartbeat_loop(self): ...
./condenser_cooling_water_source/condenser_cooling_water_source.py:    def _dealerListener(self):
./condenser_cooling_water_source/condenser_cooling_water_source.py:        while True:
./condenser_cooling_water_source/condenser_cooling_water_source.py:            try:
./condenser_cooling_water_source/condenser_cooling_water_source.py:                identity, msg = self.ctrl.recv_multipart(flags=zmq.NOBLOCK)
./condenser_cooling_water_source/condenser_cooling_water_source.py:                if identity or msg:
./condenser_cooling_water_source/condenser_cooling_water_source.py:                    decoded_msg = json.loads(msg.decode())
./condenser_cooling_water_source/condenser_cooling_water_source.py:                    if (
./condenser_cooling_water_source/condenser_cooling_water_source.py:                        decoded_msg["type"] == "command"
./condenser_cooling_water_source/condenser_cooling_water_source.py:                        and decoded_msg["name"] == "control_system"
./condenser_cooling_water_source/condenser_cooling_water_source.py:                    ):
./condenser_cooling_water_source/condenser_cooling_water_source.py:                        self._executation(decoded_msg)
./condenser_cooling_water_source/condenser_cooling_water_source.py:            except zmq.Again:
./condenser_cooling_water_source/condenser_cooling_water_source.py:                pass
./condenser_cooling_water_source/condenser_cooling_water_source.py:            time.sleep(0.05)
./condenser_cooling_water_source/condenser_cooling_water_source.py:
./condenser_cooling_water_source/condenser_cooling_water_source.py:    def _executation(self, msg):
./condenser_cooling_water_source/condenser_cooling_water_source.py:        cmd = msg["command"]
./condenser_cooling_water_source/condenser_cooling_water_source.py:        if cmd == "establish_connections":
./condenser_cooling_water_source/condenser_cooling_water_source.py:            cc = self.establish_connections()
./condenser_cooling_water_source/condenser_cooling_water_source.py:            self.send_msg(
./condenser_cooling_water_source/condenser_cooling_water_source.py:                f"Establish-ED Connections of {cc} at {self.name}", type_="status"
./condenser_cooling_water_source/condenser_cooling_water_source.py:            )
./condenser_cooling_water_source/condenser_cooling_water_source.py:
./condenser_cooling_water_source/condenser_cooling_water_source.py:        else:
./condenser_cooling_water_source/condenser_cooling_water_source.py:            self.send_msg("Error", ok=False, error="unknown command")
./condenser_cooling_water_source/condenser_cooling_water_source.py:
./condenser_cooling_water_source/condenser_cooling_water_source.py:    def send_msg(self, msg, type_="status", **kwargs):
./condenser_cooling_water_source/condenser_cooling_water_source.py:        data = {
./condenser_cooling_water_source/condenser_cooling_water_source.py:            "type": type_,
./condenser_cooling_water_source/condenser_cooling_water_source.py:            "name": self.name,
./condenser_cooling_water_source/condenser_cooling_water_source.py:            "status": f"{'Running' if self.running else 'Not Running'}",
./condenser_cooling_water_source/condenser_cooling_water_source.py:            "msg": msg,
./condenser_cooling_water_source/condenser_cooling_water_source.py:            **kwargs,
./condenser_cooling_water_source/condenser_cooling_water_source.py:        }
./condenser_cooling_water_source/condenser_cooling_water_source.py:        self.ctrl.send_multipart([b"", json.dumps(data).encode()])
./condenser_cooling_water_source/condenser_cooling_water_source.py:
./condenser_cooling_water_source/condenser_cooling_water_source.py:
./condenser_cooling_water_source/condenser_cooling_water_source.py:if __name__ == "__main__":
./condenser_cooling_water_source/condenser_cooling_water_source.py:    try:
./condenser_cooling_water_source/condenser_cooling_water_source.py:        water_source = CondenserCoolingWaterSource()
./condenser_cooling_water_source/condenser_cooling_water_source.py:        water_source.start()
./condenser_cooling_water_source/condenser_cooling_water_source.py:    except KeyboardInterrupt:
./condenser_cooling_water_source/condenser_cooling_water_source.py:        print("Keyboard Interrupt !!!")
./condenser_cooling_water_source/condenser_cooling_water_source.py:    except EOFError:
./condenser_cooling_water_source/condenser_cooling_water_source.py:        print("EOF Error !!!")
./telemetry_logging/telemetry.py:import os
./telemetry_logging/telemetry.py:import sys
./telemetry_logging/telemetry.py:sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
./telemetry_logging/telemetry.py:from lib.lib import *
./telemetry_logging/telemetry.py:
./telemetry_logging/telemetry.py:import time, json, threading, random
./telemetry_logging/telemetry.py:import zmq
./telemetry_logging/telemetry.py:import yaml
./telemetry_logging/telemetry.py:
./telemetry_logging/telemetry.py:class Telemetry:
./telemetry_logging/telemetry.py:    def __init__(self,):
./telemetry_logging/telemetry.py:        with open(config_file_name(), "r") as file:
./telemetry_logging/telemetry.py:            self.config = yaml.safe_load(file)
./telemetry_logging/telemetry.py:
./telemetry_logging/telemetry.py:        # pprint(self.config)
./telemetry_logging/telemetry.py:        self.ctx = zmq.Context()
./telemetry_logging/telemetry.py:        self.ctrl_endpoint = self.config["connections"]["ctrl"]["endpoint"]
./telemetry_logging/telemetry.py:        self.tick_endpoint = self.config["connections"]["tick"]["endpoint"]
./telemetry_logging/telemetry.py:        self.heartbeat_endpoint = self.config["connections"]["heartbeat"]["endpoint"]
./telemetry_logging/telemetry.py:        self.telemetry_endpoint = self.config["connections"]["telemetry"]["endpoint"]
./telemetry_logging/telemetry.py:
./telemetry_logging/telemetry.py:        self.ctrl = self.ctx.socket(
./telemetry_logging/telemetry.py:            getattr(zmq, self.config["connections"]["ctrl"]["type"])
./telemetry_logging/telemetry.py:        )
./telemetry_logging/telemetry.py:        # self.ctrl.connect(self.ctrl_endpoint)
./telemetry_logging/telemetry.py:        self.name = get_name()
./telemetry_logging/telemetry.py:        self.ctrl.setsockopt_string(zmq.IDENTITY, self.name)
./telemetry_logging/telemetry.py:
./telemetry_logging/telemetry.py:        self.tick = self.ctx.socket(
./telemetry_logging/telemetry.py:            getattr(zmq, self.config["connections"]["tick"]["type"])
./telemetry_logging/telemetry.py:        )
./telemetry_logging/telemetry.py:        self.tick.setsockopt_string(zmq.SUBSCRIBE, "")
./telemetry_logging/telemetry.py:
./telemetry_logging/telemetry.py:        self.heartbeat = self.ctx.socket(
./telemetry_logging/telemetry.py:            getattr(zmq, self.config["connections"]["heartbeat"]["type"])
./telemetry_logging/telemetry.py:        )
./telemetry_logging/telemetry.py:        self.telemetry = self.ctx.socket(
./telemetry_logging/telemetry.py:            getattr(zmq, self.config["connections"]["telemetry"]["type"])
./telemetry_logging/telemetry.py:        )
./telemetry_logging/telemetry.py:
./telemetry_logging/telemetry.py:        get_connection_object(self.ctrl, self.config["connections"]["ctrl"]["type"])(self.ctrl_endpoint)
./telemetry_logging/telemetry.py:        get_connection_object(self.telemetry, self.config["connections"]["telemetry"]["type"])(self.telemetry_endpoint)
./telemetry_logging/telemetry.py:        self.running = False
./telemetry_logging/telemetry.py:
./telemetry_logging/telemetry.py:    def establish_connections(self):
./telemetry_logging/telemetry.py:        self.running = True
./telemetry_logging/telemetry.py:        get_connection_object(self.tick, self.config["connections"]["tick"]["type"])(self.tick_endpoint)
./telemetry_logging/telemetry.py:        get_connection_object(self.heartbeat, self.config["connections"]["heartbeat"]["type"])(self.heartbeat_endpoint)
./telemetry_logging/telemetry.py:        self.tick_thread.start()
./telemetry_logging/telemetry.py:        return "Tick and HeartBeat"
./telemetry_logging/telemetry.py:
./telemetry_logging/telemetry.py:    def start(self):
./telemetry_logging/telemetry.py:        self.control_thread = threading.Thread(target=self._control_loop, daemon=True)
./telemetry_logging/telemetry.py:        self.control_thread.start()
./telemetry_logging/telemetry.py:        self.dealerListen_thread = threading.Thread(target=self._dealerListener, daemon=True)
./telemetry_logging/telemetry.py:        self.dealerListen_thread.start()
./telemetry_logging/telemetry.py:        self.tick_thread = threading.Thread(target=self._tick_loop, daemon=True)
./telemetry_logging/telemetry.py:        while True:
./telemetry_logging/telemetry.py:            time.sleep(1)
./telemetry_logging/telemetry.py:
./telemetry_logging/telemetry.py:    def _tick_loop(self):
./telemetry_logging/telemetry.py:        while self.running:
./telemetry_logging/telemetry.py:            try:
./telemetry_logging/telemetry.py:                data = self.tick.recv_json(flags=zmq.NOBLOCK)
./telemetry_logging/telemetry.py:                # self.send_msg(data, type_="tick-check")
./telemetry_logging/telemetry.py:                # real_sleep = self.time_step / max(self.time_scale, 1e-9)
./telemetry_logging/telemetry.py:                time.sleep(1)
./telemetry_logging/telemetry.py:            except zmq.Again:
./telemetry_logging/telemetry.py:                time.sleep(0.05)  # poll for control commands while paused
./telemetry_logging/telemetry.py:
./telemetry_logging/telemetry.py:    def _control_loop(self):
./telemetry_logging/telemetry.py:        self.send_msg("Okey", type_="check", data=random.randint(1, 1000))
./telemetry_logging/telemetry.py:        self.running = True
./telemetry_logging/telemetry.py:        while self.running:
./telemetry_logging/telemetry.py:            time.sleep(2)
./telemetry_logging/telemetry.py:
./telemetry_logging/telemetry.py:    def _heartbeat_loop(self):
./telemetry_logging/telemetry.py:        ...
./telemetry_logging/telemetry.py:
./telemetry_logging/telemetry.py:    def _dealerListener(self):
./telemetry_logging/telemetry.py:        while True:
./telemetry_logging/telemetry.py:            try:
./telemetry_logging/telemetry.py:                identity, msg = self.ctrl.recv_multipart(flags=zmq.NOBLOCK)
./telemetry_logging/telemetry.py:                if identity or msg:
./telemetry_logging/telemetry.py:                    decoded_msg = json.loads(msg.decode())
./telemetry_logging/telemetry.py:                    if (
./telemetry_logging/telemetry.py:                        decoded_msg["type"] == "command"
./telemetry_logging/telemetry.py:                        and decoded_msg["name"] == "control_system"
./telemetry_logging/telemetry.py:                    ):
./telemetry_logging/telemetry.py:                        self._executation(decoded_msg)
./telemetry_logging/telemetry.py:            except zmq.Again:
./telemetry_logging/telemetry.py:                pass
./telemetry_logging/telemetry.py:            time.sleep(0.05)
./telemetry_logging/telemetry.py:
./telemetry_logging/telemetry.py:    def _executation(self, msg):
./telemetry_logging/telemetry.py:        cmd = msg["command"]
./telemetry_logging/telemetry.py:        if cmd in ("establish_connections"):
./telemetry_logging/telemetry.py:            cc = self.establish_connections()
./telemetry_logging/telemetry.py:            self.send_msg(
./telemetry_logging/telemetry.py:                f"Establish-ED Connections of {cc} at {self.name}", type_="status"
./telemetry_logging/telemetry.py:            )
./telemetry_logging/telemetry.py:        else:
./telemetry_logging/telemetry.py:            self.send_msg("Error", ok=False, error="unknown command")
./telemetry_logging/telemetry.py:
./telemetry_logging/telemetry.py:    def send_msg(self, msg, type_="status", **kwargs):
./telemetry_logging/telemetry.py:        data = {
./telemetry_logging/telemetry.py:            "type": type_,
./telemetry_logging/telemetry.py:            "name": self.name,
./telemetry_logging/telemetry.py:            "status": f"{'Running' if self.running else 'Not Running'}",
./telemetry_logging/telemetry.py:            "msg": msg,
./telemetry_logging/telemetry.py:            **kwargs,
./telemetry_logging/telemetry.py:        }
./telemetry_logging/telemetry.py:        self.ctrl.send_multipart([b"", json.dumps(data).encode()])
./telemetry_logging/telemetry.py:
./telemetry_logging/telemetry.py:
./telemetry_logging/telemetry.py:if __name__ == "__main__":
./telemetry_logging/telemetry.py:    try:
./telemetry_logging/telemetry.py:        telemetry = Telemetry()
./telemetry_logging/telemetry.py:        telemetry.start()
./telemetry_logging/telemetry.py:    except KeyboardInterrupt:
./telemetry_logging/telemetry.py:        print("Keyboard Interrupt !!!")
./telemetry_logging/telemetry.py:    except EOFError:
./telemetry_logging/telemetry.py:        print("EOF Error !!!")
./telemetry_logging/telemetry.py:
./primary_coolant_loop/coolant.py:import os
./primary_coolant_loop/coolant.py:import sys
./primary_coolant_loop/coolant.py:sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
./primary_coolant_loop/coolant.py:from lib.lib import *
./primary_coolant_loop/coolant.py:
./primary_coolant_loop/coolant.py:import time, json, threading, random
./primary_coolant_loop/coolant.py:import zmq
./primary_coolant_loop/coolant.py:import yaml
./primary_coolant_loop/coolant.py:
./primary_coolant_loop/coolant.py:class PrimaryCoolent:
./primary_coolant_loop/coolant.py:    def __init__(self,):
./primary_coolant_loop/coolant.py:        with open(config_file_name(), "r") as file:
./primary_coolant_loop/coolant.py:            self.config = yaml.safe_load(file)
./primary_coolant_loop/coolant.py:
./primary_coolant_loop/coolant.py:        # pprint(self.config)
./primary_coolant_loop/coolant.py:        self.ctx = zmq.Context()
./primary_coolant_loop/coolant.py:        self.ctrl_endpoint = self.config["connections"]["ctrl"]["endpoint"]
./primary_coolant_loop/coolant.py:        self.tick_endpoint = self.config["connections"]["tick"]["endpoint"]
./primary_coolant_loop/coolant.py:        self.heartbeat_endpoint = self.config["connections"]["heartbeat"]["endpoint"]
./primary_coolant_loop/coolant.py:        self.telemetry_endpoint = self.config["connections"]["telemetry"]["endpoint"]
./primary_coolant_loop/coolant.py:
./primary_coolant_loop/coolant.py:        self.ctrl = self.ctx.socket(
./primary_coolant_loop/coolant.py:            getattr(zmq, self.config["connections"]["ctrl"]["type"])
./primary_coolant_loop/coolant.py:        )
./primary_coolant_loop/coolant.py:        self.name = get_name()
./primary_coolant_loop/coolant.py:        self.ctrl.setsockopt_string(zmq.IDENTITY, self.name)
./primary_coolant_loop/coolant.py:        # self.ctrl.connect(self.ctrl_endpoint)
./primary_coolant_loop/coolant.py:        get_connection_object(self.ctrl, self.config["connections"]["ctrl"]["type"])(self.ctrl_endpoint)
./primary_coolant_loop/coolant.py:
./primary_coolant_loop/coolant.py:        self.tick = self.ctx.socket(
./primary_coolant_loop/coolant.py:            getattr(zmq, self.config["connections"]["tick"]["type"])
./primary_coolant_loop/coolant.py:        )
./primary_coolant_loop/coolant.py:        self.tick.setsockopt_string(zmq.SUBSCRIBE, "")
./primary_coolant_loop/coolant.py:        self.heartbeat = self.ctx.socket(
./primary_coolant_loop/coolant.py:            getattr(zmq, self.config["connections"]["heartbeat"]["type"])
./primary_coolant_loop/coolant.py:        )
./primary_coolant_loop/coolant.py:        self.telemetry = self.ctx.socket(
./primary_coolant_loop/coolant.py:            getattr(zmq, self.config["connections"]["telemetry"]["type"])
./primary_coolant_loop/coolant.py:        )
./primary_coolant_loop/coolant.py:        self.running = False
./primary_coolant_loop/coolant.py:
./primary_coolant_loop/coolant.py:    def establish_connections(self):
./primary_coolant_loop/coolant.py:        self.running = True
./primary_coolant_loop/coolant.py:        get_connection_object(self.tick, self.config["connections"]["tick"]["type"])(self.tick_endpoint)
./primary_coolant_loop/coolant.py:        get_connection_object(self.telemetry, self.config["connections"]["telemetry"]["type"])(self.telemetry_endpoint)
./primary_coolant_loop/coolant.py:        get_connection_object(self.heartbeat, self.config["connections"]["heartbeat"]["type"])(self.heartbeat_endpoint)
./primary_coolant_loop/coolant.py:        self.tick_thread.start()
./primary_coolant_loop/coolant.py:        return "Tick, Telemetry and HeartBeat"
./primary_coolant_loop/coolant.py:
./primary_coolant_loop/coolant.py:    def start(self):
./primary_coolant_loop/coolant.py:        self.control_thread = threading.Thread(target=self._control_loop, daemon=True)
./primary_coolant_loop/coolant.py:        self.control_thread.start()
./primary_coolant_loop/coolant.py:        self.dealerListen_thread = threading.Thread(target=self._dealerListener, daemon=True)
./primary_coolant_loop/coolant.py:        self.dealerListen_thread.start()
./primary_coolant_loop/coolant.py:        self.tick_thread = threading.Thread(target=self._tick_loop, daemon=True)
./primary_coolant_loop/coolant.py:
./primary_coolant_loop/coolant.py:        while True:
./primary_coolant_loop/coolant.py:            time.sleep(1)
./primary_coolant_loop/coolant.py:
./primary_coolant_loop/coolant.py:    def _tick_loop(self):
./primary_coolant_loop/coolant.py:        while self.running:
./primary_coolant_loop/coolant.py:            try:
./primary_coolant_loop/coolant.py:                data = self.tick.recv_json(flags=zmq.NOBLOCK)
./primary_coolant_loop/coolant.py:                # self.send_msg(data, type_="tick-check")
./primary_coolant_loop/coolant.py:                # real_sleep = self.time_step / max(self.time_scale, 1e-9)
./primary_coolant_loop/coolant.py:                time.sleep(1)
./primary_coolant_loop/coolant.py:            except zmq.Again:
./primary_coolant_loop/coolant.py:                time.sleep(0.05)  # poll for control commands while paused
./primary_coolant_loop/coolant.py:
./primary_coolant_loop/coolant.py:    def _control_loop(self):
./primary_coolant_loop/coolant.py:        self.send_msg("Okey", type_="check", data=random.randint(1, 1000))
./primary_coolant_loop/coolant.py:        self.running = True
./primary_coolant_loop/coolant.py:        while self.running:
./primary_coolant_loop/coolant.py:            time.sleep(2)
./primary_coolant_loop/coolant.py:
./primary_coolant_loop/coolant.py:    def _heartbeat_loop(self):
./primary_coolant_loop/coolant.py:        ...
./primary_coolant_loop/coolant.py:
./primary_coolant_loop/coolant.py:    def _dealerListener(self):
./primary_coolant_loop/coolant.py:        while True:
./primary_coolant_loop/coolant.py:            try:
./primary_coolant_loop/coolant.py:                identity, msg = self.ctrl.recv_multipart(flags=zmq.NOBLOCK)
./primary_coolant_loop/coolant.py:                if identity or msg:
./primary_coolant_loop/coolant.py:                    decoded_msg = json.loads(msg.decode())
./primary_coolant_loop/coolant.py:                    if (
./primary_coolant_loop/coolant.py:                        decoded_msg["type"] == "command"
./primary_coolant_loop/coolant.py:                        and decoded_msg["name"] == "control_system"
./primary_coolant_loop/coolant.py:                    ):
./primary_coolant_loop/coolant.py:                        self._executation(decoded_msg)
./primary_coolant_loop/coolant.py:            except zmq.Again:
./primary_coolant_loop/coolant.py:                pass
./primary_coolant_loop/coolant.py:            time.sleep(0.05)
./primary_coolant_loop/coolant.py:
./primary_coolant_loop/coolant.py:    def _executation(self, msg):
./primary_coolant_loop/coolant.py:        cmd = msg["command"]
./primary_coolant_loop/coolant.py:        if cmd == "establish_connections":
./primary_coolant_loop/coolant.py:            cc = self.establish_connections()
./primary_coolant_loop/coolant.py:            self.send_msg(
./primary_coolant_loop/coolant.py:                f"Establish-ED Connections of {cc} at {self.name}", type_="status"
./primary_coolant_loop/coolant.py:            )
./primary_coolant_loop/coolant.py:
./primary_coolant_loop/coolant.py:        else:
./primary_coolant_loop/coolant.py:            self.send_msg("Error", ok=False, error="unknown command")
./primary_coolant_loop/coolant.py:
./primary_coolant_loop/coolant.py:    def send_msg(self, msg, type_="status", **kwargs):
./primary_coolant_loop/coolant.py:        data = {
./primary_coolant_loop/coolant.py:            "type": type_,
./primary_coolant_loop/coolant.py:            "name": self.name,
./primary_coolant_loop/coolant.py:            "status": f"{'Running' if self.running else 'Not Running'}",
./primary_coolant_loop/coolant.py:            "msg": msg,
./primary_coolant_loop/coolant.py:            **kwargs,
./primary_coolant_loop/coolant.py:        }
./primary_coolant_loop/coolant.py:        self.ctrl.send_multipart([b"", json.dumps(data).encode()])
./primary_coolant_loop/coolant.py:
./primary_coolant_loop/coolant.py:
./primary_coolant_loop/coolant.py:if __name__ == "__main__":
./primary_coolant_loop/coolant.py:    try:
./primary_coolant_loop/coolant.py:        pc1 = PrimaryCoolent()
./primary_coolant_loop/coolant.py:        pc1.start()
./primary_coolant_loop/coolant.py:    except KeyboardInterrupt:
./primary_coolant_loop/coolant.py:        print("Keyboard Interrupt !!!")
./primary_coolant_loop/coolant.py:    except EOFError:
./primary_coolant_loop/coolant.py:        print("EOF Error !!!")
./primary_coolant_loop/coolant.py:
./master_clock/master_clock.py:import os
./master_clock/master_clock.py:import sys
./master_clock/master_clock.py:
./master_clock/master_clock.py:sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
./master_clock/master_clock.py:from lib.lib import *
./master_clock/master_clock.py:
./master_clock/master_clock.py:import time, json, threading
./master_clock/master_clock.py:import zmq
./master_clock/master_clock.py:import yaml
./master_clock/master_clock.py:import random
./master_clock/master_clock.py:
./master_clock/master_clock.py:
./master_clock/master_clock.py:class ClockService:
./master_clock/master_clock.py:    def __init__(self):
./master_clock/master_clock.py:
./master_clock/master_clock.py:        with open(config_file_name(), "r") as file:
./master_clock/master_clock.py:            self.config = yaml.safe_load(file)
./master_clock/master_clock.py:
./master_clock/master_clock.py:        self.name = get_name()
./master_clock/master_clock.py:        self.ctx = zmq.Context()
./master_clock/master_clock.py:        self.ctrl_endpoint = self.config["connections"]["ctrl"]["endpoint"]
./master_clock/master_clock.py:        self.tick_endpoint = self.config["connections"]["tick"]["endpoint"]
./master_clock/master_clock.py:        self.heartbeat_endpoint = self.config["connections"]["heartbeat"]["endpoint"]
./master_clock/master_clock.py:        self.telemetry_endpoint = self.config["connections"]["telemetry"]["endpoint"]
./master_clock/master_clock.py:
./master_clock/master_clock.py:        self.ctrl = self.ctx.socket(
./master_clock/master_clock.py:            getattr(zmq, self.config["connections"]["ctrl"]["type"])
./master_clock/master_clock.py:        )
./master_clock/master_clock.py:        self.ctrl.setsockopt_string(zmq.IDENTITY, self.name)
./master_clock/master_clock.py:
./master_clock/master_clock.py:        self.tick = self.ctx.socket(
./master_clock/master_clock.py:            getattr(zmq, self.config["connections"]["tick"]["type"])
./master_clock/master_clock.py:        )
./master_clock/master_clock.py:
./master_clock/master_clock.py:        self.heartbeat = self.ctx.socket(
./master_clock/master_clock.py:            getattr(zmq, self.config["connections"]["heartbeat"]["type"])
./master_clock/master_clock.py:        )
./master_clock/master_clock.py:        self.telemetry = self.ctx.socket(
./master_clock/master_clock.py:            getattr(zmq, self.config["connections"]["telemetry"]["type"])
./master_clock/master_clock.py:        )
./master_clock/master_clock.py:
./master_clock/master_clock.py:        get_connection_object(self.ctrl, self.config["connections"]["ctrl"]["type"])(
./master_clock/master_clock.py:            self.ctrl_endpoint
./master_clock/master_clock.py:        )
./master_clock/master_clock.py:        get_connection_object(self.tick, self.config["connections"]["tick"]["type"])(
./master_clock/master_clock.py:            self.tick_endpoint
./master_clock/master_clock.py:        )
./master_clock/master_clock.py:
./master_clock/master_clock.py:        # ------------------------------------------------------------------------------------------------------------------------
./master_clock/master_clock.py:        self.sim_time = 0.0
./master_clock/master_clock.py:        self.tick_index = 0
./master_clock/master_clock.py:        self.time_step = 1.0
./master_clock/master_clock.py:        self.time_scale = 1.0
./master_clock/master_clock.py:        self.paused = False
./master_clock/master_clock.py:        self.running = True
./master_clock/master_clock.py:        self.connections = False
./master_clock/master_clock.py:        self.heartbeat_interval = 5.0
./master_clock/master_clock.py:
./master_clock/master_clock.py:    def start(self):
./master_clock/master_clock.py:        self.contorl_thread = threading.Thread(target=self._control_loop, daemon=True)
./master_clock/master_clock.py:        self.contorl_thread.start()
./master_clock/master_clock.py:
./master_clock/master_clock.py:        self.dealerListener_thread = threading.Thread(
./master_clock/master_clock.py:            target=self._dealerListener, daemon=True
./master_clock/master_clock.py:        )
./master_clock/master_clock.py:        self.dealerListener_thread.start()
./master_clock/master_clock.py:
./master_clock/master_clock.py:        self.heartbeat_thread = threading.Thread(
./master_clock/master_clock.py:            target=self._heartbeat_loop, daemon=True
./master_clock/master_clock.py:        )
./master_clock/master_clock.py:        self.tick_therad = threading.Thread(target=self._tick_loop, daemon=True)
./master_clock/master_clock.py:        self.tick_therad.start()
./master_clock/master_clock.py:        while True:
./master_clock/master_clock.py:            time.sleep(1)
./master_clock/master_clock.py:
./master_clock/master_clock.py:    def establish_connections(self):
./master_clock/master_clock.py:        get_connection_object(
./master_clock/master_clock.py:            self.telemetry, self.config["connections"]["telemetry"]["type"]
./master_clock/master_clock.py:        )(self.telemetry_endpoint)
./master_clock/master_clock.py:        get_connection_object(
./master_clock/master_clock.py:            self.heartbeat, self.config["connections"]["heartbeat"]["type"]
./master_clock/master_clock.py:        )(self.heartbeat_endpoint)
./master_clock/master_clock.py:        self.heartbeat_thread.start()
./master_clock/master_clock.py:        self.connections = True
./master_clock/master_clock.py:        return "Telemetry and Heartbeat"
./master_clock/master_clock.py:
./master_clock/master_clock.py:    def _tick_loop(self):
./master_clock/master_clock.py:        while not self.connections:
./master_clock/master_clock.py:            time.sleep(0.1)
./master_clock/master_clock.py:        self.send_msg("Tick Started", type_="status", tick_status="started")
./master_clock/master_clock.py:        while self.running:
./master_clock/master_clock.py:            if not self.paused and self.time_scale > 0:
./master_clock/master_clock.py:                self.tick_index += 1
./master_clock/master_clock.py:                self.sim_time += self.time_step
./master_clock/master_clock.py:                msg = {
./master_clock/master_clock.py:                    "type": "tick",
./master_clock/master_clock.py:                    "sim_time": self.sim_time,
./master_clock/master_clock.py:                    "tick_index": self.tick_index,
./master_clock/master_clock.py:                    "time_step": self.time_step,
./master_clock/master_clock.py:                    "time_scale": self.time_scale,
./master_clock/master_clock.py:                    "running": True,
./master_clock/master_clock.py:                }
./master_clock/master_clock.py:                self.tick.send_json(msg)
./master_clock/master_clock.py:                # self.send_msg(msg)
./master_clock/master_clock.py:
./master_clock/master_clock.py:                real_sleep = self.time_step / max(self.time_scale, 1e-9)
./master_clock/master_clock.py:                time.sleep(real_sleep)
./master_clock/master_clock.py:            else:
./master_clock/master_clock.py:                time.sleep(0.05)  # poll for control commands while paused
./master_clock/master_clock.py:
./master_clock/master_clock.py:    def _control_loop(self):
./master_clock/master_clock.py:        self.send_msg("Okey", type_="check", data=random.randint(1, 1000))
./master_clock/master_clock.py:        while True:
./master_clock/master_clock.py:            try:
./master_clock/master_clock.py:                identity, msg = self.ctrl.recv_multipart(flags=zmq.NOBLOCK)
./master_clock/master_clock.py:                jsonify_msg = json.loads(msg.decode())
./master_clock/master_clock.py:            except zmq.Again:
./master_clock/master_clock.py:                pass
./master_clock/master_clock.py:            time.sleep(1)
./master_clock/master_clock.py:
./master_clock/master_clock.py:    def _dealerListener(self):
./master_clock/master_clock.py:        while True:
./master_clock/master_clock.py:            try:
./master_clock/master_clock.py:                identity, msg = self.ctrl.recv_multipart(flags=zmq.NOBLOCK)
./master_clock/master_clock.py:                if identity or msg:
./master_clock/master_clock.py:                    decoded_msg = json.loads(msg.decode())
./master_clock/master_clock.py:                    if (
./master_clock/master_clock.py:                        decoded_msg["type"] == "command"
./master_clock/master_clock.py:                        and decoded_msg["name"] == "control_system"
./master_clock/master_clock.py:                    ):
./master_clock/master_clock.py:                        self._executation(decoded_msg)
./master_clock/master_clock.py:            except zmq.Again:
./master_clock/master_clock.py:                pass
./master_clock/master_clock.py:            time.sleep(0.05)
./master_clock/master_clock.py:
./master_clock/master_clock.py:    def _executation(self, jsonify_msg, *args):
./master_clock/master_clock.py:        cmd = jsonify_msg["command"]
./master_clock/master_clock.py:        if cmd == "pause":
./master_clock/master_clock.py:            self.paused = True
./master_clock/master_clock.py:            self.send_msg("Paused")
./master_clock/master_clock.py:        elif cmd == "resume":
./master_clock/master_clock.py:            self.paused = False
./master_clock/master_clock.py:            self.send_msg("Resume")
./master_clock/master_clock.py:        elif cmd == "scale":
./master_clock/master_clock.py:            # val = float(req.get("value", 1.0))
./master_clock/master_clock.py:            self.time_scale = jsonify_msg["value"]
./master_clock/master_clock.py:            self.send_msg("scalling time", time_scale=self.time_scale)
./master_clock/master_clock.py:        elif cmd == "step":
./master_clock/master_clock.py:            # cnt = int(req.get("count", 1))
./master_clock/master_clock.py:            # # do synchronous steps (while paused)
./master_clock/master_clock.py:            # if self.paused:
./master_clock/master_clock.py:            #     for _ in range(cnt):
./master_clock/master_clock.py:            #         self.tick_index += 1
./master_clock/master_clock.py:            #         self.sim_time += self.time_step
./master_clock/master_clock.py:            #         msg = {
./master_clock/master_clock.py:            #             "type": "tick",
./master_clock/master_clock.py:            #             "sim_time": self.sim_time,
./master_clock/master_clock.py:            #             "tick_index": self.tick_index,
./master_clock/master_clock.py:            #             "time_step": self.time_step,
./master_clock/master_clock.py:            #             "time_scale": self.time_scale,
./master_clock/master_clock.py:            #             "running": False,
./master_clock/master_clock.py:            #         }
./master_clock/master_clock.py:            #         self.pub.send_json(msg)
./master_clock/master_clock.py:            #     self.rep.send_json({"ok": True, "msg": f"stepped {cnt}"})
./master_clock/master_clock.py:            # else:
./master_clock/master_clock.py:            #     self.rep.send_json({"ok": False, "error": "not paused"})
./master_clock/master_clock.py:            ...
./master_clock/master_clock.py:        elif cmd == "status":
./master_clock/master_clock.py:            self.send_msg(
./master_clock/master_clock.py:                "status info",
./master_clock/master_clock.py:                sim_time=self.sim_time,
./master_clock/master_clock.py:                time_scale=self.time_scale,
./master_clock/master_clock.py:                paused=self.paused,
./master_clock/master_clock.py:            )
./master_clock/master_clock.py:        elif cmd == "stop":
./master_clock/master_clock.py:            self.running = False
./master_clock/master_clock.py:            self.send_msg("Stopping")
./master_clock/master_clock.py:        elif cmd == "ready":
./master_clock/master_clock.py:            self.send_msg("ready or not", ok=True)
./master_clock/master_clock.py:        elif cmd == "establish_connections":
./master_clock/master_clock.py:            cc = self.establish_connections()
./master_clock/master_clock.py:            self.send_msg(
./master_clock/master_clock.py:                f"Establish-ED Connections of {cc} at {self.name}", type_="status"
./master_clock/master_clock.py:            )
./master_clock/master_clock.py:        else:
./master_clock/master_clock.py:            self.send_msg("Error", ok=False, error="unknown command")
./master_clock/master_clock.py:
./master_clock/master_clock.py:    def send_msg(self, msg, type_="status", **kwargs):
./master_clock/master_clock.py:        data = {
./master_clock/master_clock.py:            "type": type_,
./master_clock/master_clock.py:            "name": self.name,
./master_clock/master_clock.py:            "status": f"{'Running' if self.running else 'Not Running'}",
./master_clock/master_clock.py:            "msg": msg,
./master_clock/master_clock.py:            **kwargs,
./master_clock/master_clock.py:        }
./master_clock/master_clock.py:        self.ctrl.send_multipart([b"", json.dumps(data).encode()])
./master_clock/master_clock.py:
./master_clock/master_clock.py:    def _heartbeat_loop(self): ...
./master_clock/master_clock.py:
./master_clock/master_clock.py:
./master_clock/master_clock.py:if __name__ == "__main__":
./master_clock/master_clock.py:    try:
./master_clock/master_clock.py:        clock = ClockService()
./master_clock/master_clock.py:        clock.start()
./master_clock/master_clock.py:    except KeyboardInterrupt:
./master_clock/master_clock.py:        print("Keyboard Interrupt !!!")
./master_clock/master_clock.py:    except EOFError:
./master_clock/master_clock.py:        print("EOF Error !!!")
./control_safety/control_system.py:#!/usr/bin/env python
./control_safety/control_system.py:
./control_safety/control_system.py:import os
./control_safety/control_system.py:import sys
./control_safety/control_system.py:
./control_safety/control_system.py:sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
./control_safety/control_system.py:from lib.lib import *
./control_safety/control_system.py:
./control_safety/control_system.py:import zmq
./control_safety/control_system.py:import time
./control_safety/control_system.py:import random
./control_safety/control_system.py:import yaml
./control_safety/control_system.py:import json
./control_safety/control_system.py:
./control_safety/control_system.py:from prompt_toolkit.application import Application
./control_safety/control_system.py:from prompt_toolkit.key_binding import KeyBindings
./control_safety/control_system.py:from prompt_toolkit.layout import Layout, HSplit, VSplit, Window
./control_safety/control_system.py:from prompt_toolkit.widgets import TextArea
./control_safety/control_system.py:import threading
./control_safety/control_system.py:
./control_safety/control_system.py:
./control_safety/control_system.py:class ControlSystem:
./control_safety/control_system.py:    def __init__(self):
./control_safety/control_system.py:        with open(config_file_name(), "r") as file:
./control_safety/control_system.py:            self.config = yaml.safe_load(file)
./control_safety/control_system.py:
./control_safety/control_system.py:        self.name = get_name()
./control_safety/control_system.py:
./control_safety/control_system.py:        self.ctx = zmq.Context()
./control_safety/control_system.py:        self.ctrl_endpoint = self.config["connections"]["ctrl"]["endpoint"]
./control_safety/control_system.py:        self.tick_endpoint = self.config["connections"]["tick"]["endpoint"]
./control_safety/control_system.py:        self.heartbeat_endpoint = self.config["connections"]["heartbeat"]["endpoint"]
./control_safety/control_system.py:        self.telemetry_endpoint = self.config["connections"]["telemetry"]["endpoint"]
./control_safety/control_system.py:
./control_safety/control_system.py:        self.ctrl = self.ctx.socket(
./control_safety/control_system.py:            getattr(zmq, self.config["connections"]["ctrl"]["type"])
./control_safety/control_system.py:        )
./control_safety/control_system.py:        self.ctrl.setsockopt_string(zmq.IDENTITY, self.name)
./control_safety/control_system.py:        get_connection_object(self.ctrl, self.config["connections"]["ctrl"]["type"])(
./control_safety/control_system.py:            self.ctrl_endpoint
./control_safety/control_system.py:        )
./control_safety/control_system.py:        self.tick = self.ctx.socket(
./control_safety/control_system.py:            getattr(zmq, self.config["connections"]["tick"]["type"])
./control_safety/control_system.py:        )
./control_safety/control_system.py:        self.tick.setsockopt_string(zmq.SUBSCRIBE, "")
./control_safety/control_system.py:
./control_safety/control_system.py:        self.heartbeat = self.ctx.socket(
./control_safety/control_system.py:            getattr(zmq, self.config["connections"]["heartbeat"]["type"])
./control_safety/control_system.py:        )
./control_safety/control_system.py:        self.telemetry = self.ctx.socket(
./control_safety/control_system.py:            getattr(zmq, self.config["connections"]["telemetry"]["type"])
./control_safety/control_system.py:        )
./control_safety/control_system.py:
./control_safety/control_system.py:        self.running = True
./control_safety/control_system.py:        # Top Left: read-only log/output
./control_safety/control_system.py:        self.display_pane = TextArea(
./control_safety/control_system.py:            scrollbar=True,
./control_safety/control_system.py:            focusable=False,
./control_safety/control_system.py:            height=20,
./control_safety/control_system.py:            wrap_lines=False,
./control_safety/control_system.py:            # dont_extend_height=True,
./control_safety/control_system.py:            # dont_extend_width=True,
./control_safety/control_system.py:            # read_only=True,
./control_safety/control_system.py:        )
./control_safety/control_system.py:
./control_safety/control_system.py:        # Bottom Left: read-only log/output
./control_safety/control_system.py:        self.log_pane = TextArea(
./control_safety/control_system.py:            scrollbar=True,
./control_safety/control_system.py:            focusable=False,
./control_safety/control_system.py:            wrap_lines=False,
./control_safety/control_system.py:            # dont_extend_height=True,
./control_safety/control_system.py:            # dont_extend_width=True,
./control_safety/control_system.py:            # read_only=True,
./control_safety/control_system.py:        )
./control_safety/control_system.py:
./control_safety/control_system.py:        # Top Right: Output section
./control_safety/control_system.py:        self.output_pane = TextArea(
./control_safety/control_system.py:            scrollbar=True,
./control_safety/control_system.py:            focusable=False,
./control_safety/control_system.py:            multiline=True,
./control_safety/control_system.py:            # dont_extend_height=True,
./control_safety/control_system.py:            # dont_extend_width=True,
./control_safety/control_system.py:            # read_only=True,
./control_safety/control_system.py:        )
./control_safety/control_system.py:
./control_safety/control_system.py:        # Bottom Right: editable input
./control_safety/control_system.py:        self.input_pane = TextArea(
./control_safety/control_system.py:            prompt="> ",
./control_safety/control_system.py:            scrollbar=True,
./control_safety/control_system.py:            focusable=True,
./control_safety/control_system.py:            multiline=False,
./control_safety/control_system.py:            wrap_lines=False,
./control_safety/control_system.py:            # dont_extend_height=True,
./control_safety/control_system.py:            # dont_extend_width=True,
./control_safety/control_system.py:        )
./control_safety/control_system.py:
./control_safety/control_system.py:        # Other pane:
./control_safety/control_system.py:        # Top Right: Output section
./control_safety/control_system.py:        # self.proc_output_pane = TextArea(
./control_safety/control_system.py:        #     scrollbar=True,
./control_safety/control_system.py:        #     focusable=False,
./control_safety/control_system.py:        #     multiline=True,
./control_safety/control_system.py:        #     # read_only=True,
./control_safety/control_system.py:        # )
./control_safety/control_system.py:
./control_safety/control_system.py:        # Vertical split with separator
./control_safety/control_system.py:        self.root_container = VSplit(
./control_safety/control_system.py:            [
./control_safety/control_system.py:                HSplit(
./control_safety/control_system.py:                    [
./control_safety/control_system.py:                        self.log_pane,
./control_safety/control_system.py:                        Window(height=1, char="─", style="class:line"),
./control_safety/control_system.py:                        self.display_pane,
./control_safety/control_system.py:                    ]
./control_safety/control_system.py:                ),
./control_safety/control_system.py:                Window(width=1, char="│", style="class:line"),  # separator
./control_safety/control_system.py:                HSplit(
./control_safety/control_system.py:                    [
./control_safety/control_system.py:                        # self.proc_output_pane,
./control_safety/control_system.py:                        # Window(height=1, char="─", style="class:line"),
./control_safety/control_system.py:                        self.output_pane,
./control_safety/control_system.py:                        Window(height=1, char="─", style="class:line"),  # separator
./control_safety/control_system.py:                        self.input_pane,
./control_safety/control_system.py:                    ],
./control_safety/control_system.py:                    width=80,
./control_safety/control_system.py:                ),
./control_safety/control_system.py:            ]
./control_safety/control_system.py:        )
./control_safety/control_system.py:        self.layout = Layout(
./control_safety/control_system.py:            container=self.root_container, focused_element=self.input_pane
./control_safety/control_system.py:        )
./control_safety/control_system.py:        self.kb = KeyBindings()
./control_safety/control_system.py:        self._binds()
./control_safety/control_system.py:        self.application = Application(
./control_safety/control_system.py:            layout=self.layout,
./control_safety/control_system.py:            key_bindings=self.kb,
./control_safety/control_system.py:            full_screen=True,
./control_safety/control_system.py:            mouse_support=True,
./control_safety/control_system.py:        )
./control_safety/control_system.py:        self.dealer_registry = dict()
./control_safety/control_system.py:        # self.current_log = dict()
./control_safety/control_system.py:        self.log_registry = dict()
./control_safety/control_system.py:        self.shutdown_process_started = False
./control_safety/control_system.py:        self.established_connections = False
./control_safety/control_system.py:
./control_safety/control_system.py:    def start(self):
./control_safety/control_system.py:        self.dealer_listen_thrade = threading.Thread(
./control_safety/control_system.py:            target=self._dealerListener, daemon=True
./control_safety/control_system.py:        )
./control_safety/control_system.py:        self.dealer_listen_thrade.start()
./control_safety/control_system.py:        self.tick_loop_thread = threading.Thread(target=self._tick_loop, daemon=True)
./control_safety/control_system.py:
./control_safety/control_system.py:        self.tick_loop_thread.start()
./control_safety/control_system.py:        self._window_start()
./control_safety/control_system.py:        if self.running == False:
./control_safety/control_system.py:            ...
./control_safety/control_system.py:
./control_safety/control_system.py:    def establish_connections(self):
./control_safety/control_system.py:        get_connection_object(self.tick, self.config["connections"]["tick"]["type"])(
./control_safety/control_system.py:            self.tick_endpoint
./control_safety/control_system.py:        )
./control_safety/control_system.py:        get_connection_object(
./control_safety/control_system.py:            self.telemetry, self.config["connections"]["telemetry"]["type"]
./control_safety/control_system.py:        )(self.telemetry_endpoint)
./control_safety/control_system.py:        get_connection_object(
./control_safety/control_system.py:            self.heartbeat, self.config["connections"]["heartbeat"]["type"]
./control_safety/control_system.py:        )(self.heartbeat_endpoint)
./control_safety/control_system.py:
./control_safety/control_system.py:    def _binds(self):
./control_safety/control_system.py:        @self.kb.add("c-c")
./control_safety/control_system.py:        def exit(event):
./control_safety/control_system.py:            "Quit with Ctrl-C."
./control_safety/control_system.py:            self.running = False
./control_safety/control_system.py:            event.app.exit()
./control_safety/control_system.py:
./control_safety/control_system.py:        @self.kb.add("enter")
./control_safety/control_system.py:        def take_input(event):
./control_safety/control_system.py:            text = self.input_pane.text.strip()
./control_safety/control_system.py:            if text:
./control_safety/control_system.py:                # formatted = FormattedText([("class:input_text", f"> {text}\n")])
./control_safety/control_system.py:                self.output_pane.buffer.insert_text(f"> {text}\n")
./control_safety/control_system.py:                self._executation(text)
./control_safety/control_system.py:                self.input_pane.text = ""
./control_safety/control_system.py:
./control_safety/control_system.py:    def _executation(self, inStr):
./control_safety/control_system.py:        help = """
./control_safety/control_system.py:    p   - pause     : This will pause the entire simulation system.
./control_safety/control_system.py:    r   - resume    : This will resume the paused system.
./control_safety/control_system.py:    s   - scale     : This will increse the scale of simulation by the factor of 1.
./control_safety/control_system.py:    st  - step      : This will increse the speed of the simulation by the 1x.
./control_safety/control_system.py:    S   - status    : This will show status of all the systems.
./control_safety/control_system.py:    R   - ready     : This will force refresh the display_pane, and force check if all the compontes are ready to start.
./control_safety/control_system.py:    e   - exit      : This will gracefull quit the simulation program.
./control_safety/control_system.py:    ...
./control_safety/control_system.py:        """
./control_safety/control_system.py:
./control_safety/control_system.py:        inStr_list = inStr.split(" ")
./control_safety/control_system.py:        if not self.shutdown_process_started:
./control_safety/control_system.py:            if inStr in ("p", "pause"):
./control_safety/control_system.py:                ...
./control_safety/control_system.py:            elif inStr in ("r", "resume"):
./control_safety/control_system.py:                ...
./control_safety/control_system.py:            elif inStr in ("s", "scale"):
./control_safety/control_system.py:                ...
./control_safety/control_system.py:            elif inStr in ("st", "step"):
./control_safety/control_system.py:                ...
./control_safety/control_system.py:            elif inStr in ("S", "status"):
./control_safety/control_system.py:                ...
./control_safety/control_system.py:            elif inStr in ("R", "ready"):
./control_safety/control_system.py:                ...
./control_safety/control_system.py:            elif inStr in ("cc", "clear"):
./control_safety/control_system.py:                # self.display_pane.text = ""
./control_safety/control_system.py:                self.log_pane.text = ""
./control_safety/control_system.py:                self.output_pane.text = ""
./control_safety/control_system.py:            elif inStr == "ref":
./control_safety/control_system.py:                self.application.renderer.clear()
./control_safety/control_system.py:                self.application._redraw()
./control_safety/control_system.py:            elif inStr == "asdf" or inStr == "e" or inStr == "quit" or inStr == "exit":
./control_safety/control_system.py:                self.shutdown_process_started = True
./control_safety/control_system.py:                self.sendCmd("runner", "shutdown", "system shutdown")
./control_safety/control_system.py:                # self.ctrl.send_multipart(
./control_safety/control_system.py:                #     [
./control_safety/control_system.py:                #         "runner".encode(),
./control_safety/control_system.py:                #         b"",
./control_safety/control_system.py:                #         json.dumps(
./control_safety/control_system.py:                #             {
./control_safety/control_system.py:                #                 "type": "command",
./control_safety/control_system.py:                #                 "command": "shutdown",
./control_safety/control_system.py:                #                 "msg": "system shutdown",
./control_safety/control_system.py:                #             }
./control_safety/control_system.py:                #         ).encode(),
./control_safety/control_system.py:                #     ]
./control_safety/control_system.py:                #
./control_safety/control_system.py:            elif inStr in ("h", "help"):
./control_safety/control_system.py:                self.output_pane.buffer.insert_text(help + "\n")
./control_safety/control_system.py:            elif (
./control_safety/control_system.py:                len(inStr_list) >= 2
./control_safety/control_system.py:                and inStr_list[0] == "test"
./control_safety/control_system.py:                and inStr_list[1] in self.dealer_registry.keys()
./control_safety/control_system.py:                and self.established_connections
./control_safety/control_system.py:            ):
./control_safety/control_system.py:                threading.Thread(
./control_safety/control_system.py:                    target=self.test_msg,
./control_safety/control_system.py:                    daemon=True,
./control_safety/control_system.py:                    args=[
./control_safety/control_system.py:                        inStr_list[1],
./control_safety/control_system.py:                        int(inStr_list[2:3][0]) if len(inStr_list[2:3]) else 5,
./control_safety/control_system.py:                        int(inStr_list[3:4][0]) if len(inStr_list[3:4]) else 1,
./control_safety/control_system.py:                    ],
./control_safety/control_system.py:                ).start()
./control_safety/control_system.py:            elif (
./control_safety/control_system.py:                len(inStr_list) >= 2
./control_safety/control_system.py:                and inStr_list[0] == "reactor"
./control_safety/control_system.py:                and inStr_list[1] == "part-sim-start"
./control_safety/control_system.py:                and self.established_connections
./control_safety/control_system.py:            ):
./control_safety/control_system.py:                self.sendCmd(
./control_safety/control_system.py:                    "reactor",
./control_safety/control_system.py:                    "start-partical-sim-thread",
./control_safety/control_system.py:                    "start the partical simulation...",
./control_safety/control_system.py:                )
./control_safety/control_system.py:            else:
./control_safety/control_system.py:                self.output_pane.buffer.insert_text(
./control_safety/control_system.py:                    f"[ERROR] - type \\help for the argument definition list.\n"
./control_safety/control_system.py:                )
./control_safety/control_system.py:        else:
./control_safety/control_system.py:            if inStr in ("stop"):
./control_safety/control_system.py:                ...
./control_safety/control_system.py:
./control_safety/control_system.py:    def sendCmd(self, to_, cmd, msg):
./control_safety/control_system.py:        self.ctrl.send_multipart(
./control_safety/control_system.py:            [
./control_safety/control_system.py:                to_.encode(),
./control_safety/control_system.py:                b"",
./control_safety/control_system.py:                json.dumps(
./control_safety/control_system.py:                    {
./control_safety/control_system.py:                        "type": "command",
./control_safety/control_system.py:                        "command": cmd,
./control_safety/control_system.py:                        "name": self.name,
./control_safety/control_system.py:                        "msg": msg,
./control_safety/control_system.py:                    }
./control_safety/control_system.py:                ).encode(),
./control_safety/control_system.py:            ]
./control_safety/control_system.py:        )
./control_safety/control_system.py:
./control_safety/control_system.py:    def test_msg(self, to_, times=5, delay=1):
./control_safety/control_system.py:        for i in range(1, times + 1):
./control_safety/control_system.py:            self.send_msg(to_=to_, msg=f"checking are u okey - {i}", type_="test")
./control_safety/control_system.py:            time.sleep(delay)
./control_safety/control_system.py:
./control_safety/control_system.py:    def _dealerListener(self):
./control_safety/control_system.py:        while True:
./control_safety/control_system.py:            try:
./control_safety/control_system.py:                identity, empty, msg = self.ctrl.recv_multipart(flags=zmq.NOBLOCK)
./control_safety/control_system.py:                if msg:
./control_safety/control_system.py:                    identity_str = identity.hex()
./control_safety/control_system.py:                    decoded_msg = json.loads(msg.decode())
./control_safety/control_system.py:                    formated_time = get_time()
./control_safety/control_system.py:                    mm = decoded_msg["msg"]
./control_safety/control_system.py:                    self.dealer_registry[decoded_msg["name"]] = decoded_msg[
./control_safety/control_system.py:                        "name"
./control_safety/control_system.py:                    ].encode()
./control_safety/control_system.py:                    # self.current_log[decoded_msg["name"]] = decoded_msg
./control_safety/control_system.py:                    self.log_registry[formated_time] = mm
./control_safety/control_system.py:                    # if decoded_msg["type"] in ("status", "log", "check"):
./control_safety/control_system.py:                    self.update_log_pane(
./control_safety/control_system.py:                        t=formated_time,
./control_safety/control_system.py:                        name=decoded_msg["name"],
./control_safety/control_system.py:                        type_=decoded_msg["type"],
./control_safety/control_system.py:                        log=mm,
./control_safety/control_system.py:                    )
./control_safety/control_system.py:                    # elif decoded_msg["type"] == "proc_out/err":
./control_safety/control_system.py:                    #     self.update_proc_output_pane(mm)
./control_safety/control_system.py:                    # else:
./control_safety/control_system.py:                    #     pass
./control_safety/control_system.py:                    self._executation_p(decoded_msg)
./control_safety/control_system.py:            except zmq.Again:
./control_safety/control_system.py:                pass
./control_safety/control_system.py:            except Exception as e:
./control_safety/control_system.py:                pass
./control_safety/control_system.py:            time.sleep(0.01)
./control_safety/control_system.py:
./control_safety/control_system.py:    def _executation_p(self, decoded_msg):
./control_safety/control_system.py:        if (
./control_safety/control_system.py:            decoded_msg["name"] == "runner"
./control_safety/control_system.py:            and decoded_msg["type"] == "command"
./control_safety/control_system.py:            and decoded_msg["command"] == "control-system-shutdown"
./control_safety/control_system.py:        ):
./control_safety/control_system.py:            if self.application.is_running == True:
./control_safety/control_system.py:                self.application.exit()
./control_safety/control_system.py:        elif (
./control_safety/control_system.py:            decoded_msg["name"] == "runner"
./control_safety/control_system.py:            and decoded_msg["type"] == "command"
./control_safety/control_system.py:            and decoded_msg["command"] == "establish_connections"
./control_safety/control_system.py:        ):
./control_safety/control_system.py:            threading.Thread(
./control_safety/control_system.py:                target=self.send_msg,
./control_safety/control_system.py:                daemon=True,
./control_safety/control_system.py:                kwargs={
./control_safety/control_system.py:                    "to_": "all",
./control_safety/control_system.py:                    "type_": "command",
./control_safety/control_system.py:                    "msg": "establish_connections",
./control_safety/control_system.py:                    "command": "establish_connections",
./control_safety/control_system.py:                },
./control_safety/control_system.py:            ).start()
./control_safety/control_system.py:            # self.send_msg(to_="all", msg="establish_connections")
./control_safety/control_system.py:        elif (
./control_safety/control_system.py:            decoded_msg["name"] == "master_clock"
./control_safety/control_system.py:            and decoded_msg["type"] == "status"
./control_safety/control_system.py:            and decoded_msg["msg"] == "Tick Started"
./control_safety/control_system.py:        ):
./control_safety/control_system.py:            self.establish_connections()
./control_safety/control_system.py:            self.established_connections = True
./control_safety/control_system.py:
./control_safety/control_system.py:    def send_msg(self, to_, msg, type_="status", **kwargs):
./control_safety/control_system.py:        if type(to_) == str:
./control_safety/control_system.py:            to_ = [
./control_safety/control_system.py:                to_,
./control_safety/control_system.py:            ]
./control_safety/control_system.py:
./control_safety/control_system.py:        if to_[0] == "all":
./control_safety/control_system.py:            for id in self.dealer_registry.values():
./control_safety/control_system.py:                # self.update_log_pane(get_time(), self.name, "msg - send", f"sending msg to {id}")
./control_safety/control_system.py:                self.ctrl.send_multipart(
./control_safety/control_system.py:                    [
./control_safety/control_system.py:                        id,
./control_safety/control_system.py:                        b"",
./control_safety/control_system.py:                        json.dumps(
./control_safety/control_system.py:                            {
./control_safety/control_system.py:                                "type": type_,
./control_safety/control_system.py:                                "name": self.name,
./control_safety/control_system.py:                                "status": f"{'Running' if self.running else 'Not Running'}",
./control_safety/control_system.py:                                "msg": msg,
./control_safety/control_system.py:                                **kwargs,
./control_safety/control_system.py:                            }
./control_safety/control_system.py:                        ).encode(),
./control_safety/control_system.py:                    ]
./control_safety/control_system.py:                )
./control_safety/control_system.py:                if type_ == "test":
./control_safety/control_system.py:                    self.update_log_pane(get_time(), self.name, f"test - {id}", msg)
./control_safety/control_system.py:                time.sleep(0.5)
./control_safety/control_system.py:        elif type(to_) in (list, tuple, set):
./control_safety/control_system.py:            for id in [
./control_safety/control_system.py:                self.dealer_registry[i] for i in to_ if i in self.dealer_registry.keys()
./control_safety/control_system.py:            ]:
./control_safety/control_system.py:                self.ctrl.send_multipart(
./control_safety/control_system.py:                    [
./control_safety/control_system.py:                        id,
./control_safety/control_system.py:                        b"",
./control_safety/control_system.py:                        json.dumps(
./control_safety/control_system.py:                            {
./control_safety/control_system.py:                                "type": type_,
./control_safety/control_system.py:                                "name": self.name,
./control_safety/control_system.py:                                "status": f"{'Running' if self.running else 'Not Running'}",
./control_safety/control_system.py:                                "msg": msg,
./control_safety/control_system.py:                                **kwargs,
./control_safety/control_system.py:                            }
./control_safety/control_system.py:                        ).encode(),
./control_safety/control_system.py:                    ]
./control_safety/control_system.py:                )
./control_safety/control_system.py:                if type_ == "test":
./control_safety/control_system.py:                    self.update_log_pane(get_time(), self.name, f"test - {id}", msg)
./control_safety/control_system.py:                time.sleep(0.5)
./control_safety/control_system.py:
./control_safety/control_system.py:    # def update_display_pane(self):
./control_safety/control_system.py:    #     self.display_pane.text = ""
./control_safety/control_system.py:    #     for dealer_name, dealer_msg in self.current_log.items():
./control_safety/control_system.py:    #         self.display_pane.buffer.insert_text(f" {dealer_name} - {dealer_msg}\n")
./control_safety/control_system.py:
./control_safety/control_system.py:    def update_log_pane(self, t, name, type_, log):
./control_safety/control_system.py:        if t and log:
./control_safety/control_system.py:            self.log_pane.buffer.insert_text(
./control_safety/control_system.py:                f"{t} - {name:^30} - {type_:^15} - {log}\n"
./control_safety/control_system.py:            )
./control_safety/control_system.py:
./control_safety/control_system.py:    def thread_spawner(self): ...
./control_safety/control_system.py:
./control_safety/control_system.py:    def _window_start(self):
./control_safety/control_system.py:        self.application.run()
./control_safety/control_system.py:
./control_safety/control_system.py:    def _tick_loop(self):
./control_safety/control_system.py:        while True:
./control_safety/control_system.py:            try:
./control_safety/control_system.py:                # self.update_log_pane(get_time(), self.name, "check", "tick loop check")
./control_safety/control_system.py:                data = self.tick.recv_json(flags=zmq.NOBLOCK)
./control_safety/control_system.py:                # self.current_log["master_clock"] = data
./control_safety/control_system.py:                self.log_registry[get_time()] = data
./control_safety/control_system.py:                # self.update_display_pane()
./control_safety/control_system.py:                # self.(get_time(), "master_clock", "tick", data)
./control_safety/control_system.py:                # try:
./control_safety/control_system.py:                #     data = self.tick.recv_json()
./control_safety/control_system.py:                #     self.update_log_pane(time, data)
./control_safety/control_system.py:                # except zmq.Again:
./control_safety/control_system.py:                #     # self.update_log_pane(time, "Error in the contorl system tick loop")
./control_safety/control_system.py:                #     pass
./control_safety/control_system.py:            except zmq.Again:
./control_safety/control_system.py:                pass
./control_safety/control_system.py:            time.sleep(1)
./control_safety/control_system.py:
./control_safety/control_system.py:    def _heartbeat_loop(self): ...
./control_safety/control_system.py:
./control_safety/control_system.py:
./control_safety/control_system.py:if __name__ == "__main__":
./control_safety/control_system.py:    control_sys = ControlSystem()
./control_safety/control_system.py:    control_sys.start()
